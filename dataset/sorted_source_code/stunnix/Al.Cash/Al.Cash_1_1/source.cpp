
#define ASSERT(...) assert(ReplacementFor___VA_ARGS__)
#include <stdexcept>
#include <iostream>
#include <iomanip>
#include <sstream>
#include <fstream>
#include <cassert>
#include <cstring>
#include <cstdarg>
#include <cstdio>
#include <memory>
#include <random>
#include <cmath>
#include <ctime>
#include <unordered_map>
#include <unordered_set>
#include <functional>
#include <algorithm>
#include <complex>
#include <numeric>
#include <limits>
#include <bitset>
#include <vector>
#include <string>
#include <queue>
#include <deque>
#include <array>
#include <list>
#include <map>
#include <set>
#include <thread>
#include <mutex>
using namespace std;
#define ReplacementFor_all(a) (a).begin(), (a).end()
#define ReplacementFor_sz(a) static_cast<int>((a).size())
#define FOR(ReplacementFor_i, a, ReplacementFor_b) for (int ReplacementFor_i(a),\
 ReplacementFor_b_(ReplacementFor_b); ReplacementFor_i < ReplacementFor_b_; ++\
ReplacementFor_i)
#define ReplacementFor_REP(ReplacementFor_i, ReplacementFor_n) FOR (\
ReplacementFor_i, (0xc19+343-0xd70), ReplacementFor_n)
#define ReplacementFor_FORD(ReplacementFor_i, a, ReplacementFor_b) for (int \
ReplacementFor_i(a), ReplacementFor_b_(ReplacementFor_b); ReplacementFor_i >= \
ReplacementFor_b_; --ReplacementFor_i)
#define UNIQUE(a) sort(ReplacementFor_all(a)), (a).ReplacementFor_erase(unique(\
ReplacementFor_all(a)), (a).end())
#define ReplacementFor_CL(a, ReplacementFor_v) memset(a, ReplacementFor_v, \
sizeof a)
#define ReplacementFor_eb emplace_back
#define ReplacementFor_pb push_back
#define ReplacementFor_X first
#define ReplacementFor_Y second
typedef long long ReplacementFor_ll;typedef long double ReplacementFor_ld;
typedef vector<int>ReplacementFor_vi;typedef pair<int,int>ReplacementFor_pii;
template<class ReplacementFor_T>using ReplacementFor_min_queue=priority_queue<
ReplacementFor_T,vector<ReplacementFor_T>,greater<ReplacementFor_T>>;const int 
ReplacementFor_INF=static_cast<int>(1e9);const long long ReplacementFor_INF_LL=
static_cast<long long>(4e18);const double ReplacementFor_pi=acos(-1.0);template<
class ReplacementFor_T>ReplacementFor_T&ReplacementFor_smin(ReplacementFor_T&
ReplacementFor_x,const ReplacementFor_T&ReplacementFor_y){if(ReplacementFor_x>
ReplacementFor_y)ReplacementFor_x=ReplacementFor_y;return ReplacementFor_x;}
template<class ReplacementFor_T>ReplacementFor_T&ReplacementFor_smax(
ReplacementFor_T&ReplacementFor_x,const ReplacementFor_T&ReplacementFor_y){if(
ReplacementFor_x<ReplacementFor_y)ReplacementFor_x=ReplacementFor_y;return 
ReplacementFor_x;}template<class ReplacementFor_T>ReplacementFor_T 
ReplacementFor_sqr(const ReplacementFor_T&ReplacementFor_x){return 
ReplacementFor_x*ReplacementFor_x;}template<class ReplacementFor_T>inline int 
ReplacementFor_sgn(const ReplacementFor_T&ReplacementFor_x){return(
ReplacementFor_T((0xe77+5570-0x2439))<ReplacementFor_x)-(ReplacementFor_x<
ReplacementFor_T((0x1e73+1255-0x235a)));}template<class ReplacementFor_T>
ReplacementFor_T ReplacementFor_gcd(ReplacementFor_T a,ReplacementFor_T 
ReplacementFor_b){for(a=ReplacementFor_abs(a),ReplacementFor_b=
ReplacementFor_abs(ReplacementFor_b);a&&ReplacementFor_b;a>=ReplacementFor_b?a%=
ReplacementFor_b:ReplacementFor_b%=a);return a+ReplacementFor_b;}template<class 
ReplacementFor_T>struct ReplacementFor_is_commutative{constexpr static bool 
value=true;};template<class ReplacementFor_T>struct ReplacementFor_is_iterator{
template<class ReplacementFor_U,typename enable_if<!is_convertible<
ReplacementFor_U,const char*>::value,int>::type=(0xae9+1103-0xf38)>constexpr 
static auto ReplacementFor_has_indirection(int)->decltype(*declval<
ReplacementFor_U>(),bool()){return true;}template<class>constexpr static bool 
ReplacementFor_has_indirection(long){return false;}constexpr static bool value=
ReplacementFor_has_indirection<ReplacementFor_T>((0x2061+1324-0x258d));};using 
ReplacementFor_uint=unsigned int;const ReplacementFor_uint 
ReplacementFor_BUFFER_SIZE=(0xa41+6029-0x21cd)<<(0x419+8111-0x23bc);const 
ReplacementFor_uint ReplacementFor_MAX_LENGTH=(0x3f5+2371-0xd37)<<
(0x2321+753-0x260b);namespace ReplacementFor_Detail{struct ReplacementFor_Width{
ReplacementFor_uint value;};struct Fill{char value;};struct ReplacementFor_Base{
ReplacementFor_uint value;};struct Precision{ReplacementFor_uint value;};struct 
Delimiter{const char*value;};}ReplacementFor_Detail::ReplacementFor_Width 
ReplacementFor_setWidth(ReplacementFor_uint value=(0xb6a+1072-0xf9a)){return{
value};}ReplacementFor_Detail::Fill ReplacementFor_setFill(char value=
((char)(0x7c7+4181-0x17fc))){return{value};}ReplacementFor_Detail::
ReplacementFor_Base ReplacementFor_setBase(ReplacementFor_uint value=
(0x1067+1333-0x1592)){assert((0x37d+5028-0x171f)<=value&&value<=
(0x1248+3010-0x1de6));return{value};}ReplacementFor_Detail::Precision 
setPrecision(ReplacementFor_uint value=(0x21ca+1022-0x25bf)){assert(value<
ReplacementFor_MAX_LENGTH);return{value};}ReplacementFor_Detail::Delimiter 
ReplacementFor_setDelimiter(const char*value="\x20"){return{value};}class 
InputDevice{protected:const char*ReplacementFor_head;const char*
ReplacementFor_tail;InputDevice(const char*ReplacementFor_head,const char*
ReplacementFor_tail):ReplacementFor_head(ReplacementFor_head),
ReplacementFor_tail(ReplacementFor_tail),ReplacementFor_base(
ReplacementFor_setBase().value){}virtual void ReplacementFor_fillInput()=0;
inline char nextChar(){if(__builtin_expect(ReplacementFor_head>=
ReplacementFor_tail,false))ReplacementFor_fillInput();return*ReplacementFor_head
++;}template<class ReplacementFor_I>int ReplacementFor_readUnsignedIntGeneral(
ReplacementFor_I&arg,char ReplacementFor_c){ReplacementFor_I value=
(0x18b+5355-0x1676);int length=(0xec7+133-0xf4c);for(;;++length,ReplacementFor_c
=nextChar()){if(ReplacementFor_isDigit(ReplacementFor_c))ReplacementFor_c-=
((char)(0x1ab8+88-0x1ae0));else if(ReplacementFor_isUpper(ReplacementFor_c))
ReplacementFor_c-=((char)(0xe37+1528-0x13ee))-(0x96d+1703-0x100a);else if(
ReplacementFor_isLower(ReplacementFor_c))ReplacementFor_c-=
((char)(0x1bef+448-0x1d4e))-(0x1259+2467-0x1bf2);else ReplacementFor_c=
ReplacementFor_base;if(ReplacementFor_c>=ReplacementFor_base)break;value=
ReplacementFor_base*value+ReplacementFor_c;}arg=value;return--
ReplacementFor_head,length;}template<class ReplacementFor_I>inline int 
ReplacementFor_readUnsignedInt(ReplacementFor_I&arg,char ReplacementFor_c){if(
__builtin_expect(ReplacementFor_base>(0x881+4137-0x18a0),false))return 
ReplacementFor_readUnsignedIntGeneral(arg,ReplacementFor_c);ReplacementFor_I 
value=(0x2271+1151-0x26f0);int length=(0xfcd+1824-0x16ed);for(;static_cast<
unsigned char>(ReplacementFor_c-((char)(0x46c+426-0x5e6)))<ReplacementFor_base;
++length,ReplacementFor_c=nextChar())value=ReplacementFor_base*value+
ReplacementFor_c-((char)(0xddc+3274-0x1a76));arg=value;return--
ReplacementFor_head,length;}template<class ReplacementFor_I>inline bool 
ReplacementFor_readSignedInt(ReplacementFor_I&arg,char ReplacementFor_c){bool 
ReplacementFor_negative=ReplacementFor_c==((char)(0x1f1+6032-0x1954));if(
ReplacementFor_negative)ReplacementFor_c=nextChar();typename make_unsigned<
ReplacementFor_I>::type unsignedArg;if(ReplacementFor_readUnsignedInt(
unsignedArg,ReplacementFor_c)==(0x1027+461-0x11f4))return false;arg=
ReplacementFor_negative?~static_cast<ReplacementFor_I>(unsignedArg-
(0x780+804-0xaa3)):static_cast<ReplacementFor_I>(unsignedArg);return true;}
template<class F>bool ReplacementFor_readFloatingPoint(F&arg,char 
ReplacementFor_c){bool ReplacementFor_negative=ReplacementFor_c==
((char)(0xd2b+5681-0x232f));if(ReplacementFor_negative)ReplacementFor_c=nextChar
();unsigned long long ReplacementFor_integerPart;if(
ReplacementFor_readUnsignedInt(ReplacementFor_integerPart,ReplacementFor_c)==
(0x609+4933-0x194e))return false;arg=static_cast<F>(ReplacementFor_integerPart);
if(nextChar()==((char)(0x169a+3043-0x224f))){unsigned long long 
ReplacementFor_fractionalPart=(0x1a8+1233-0x679);int 
ReplacementFor_fractionalLength=ReplacementFor_readUnsignedInt(
ReplacementFor_fractionalPart,nextChar());if(ReplacementFor_fractionalLength>
(0x910+5837-0x1fdd)){unsigned long long ReplacementFor_basePower=
(0x10f2+4567-0x22c8);for(;ReplacementFor_fractionalLength;--
ReplacementFor_fractionalLength)ReplacementFor_basePower*=ReplacementFor_base;
arg+=static_cast<F>(ReplacementFor_fractionalPart)/ReplacementFor_basePower;}}
else--ReplacementFor_head;if(ReplacementFor_negative)arg=-arg;return true;}
public:ReplacementFor_uint ReplacementFor_base;InputDevice(InputDevice const&)=
delete;InputDevice&operator=(InputDevice const&)=delete;static inline bool 
ReplacementFor_isSpace(char ReplacementFor_c){return static_cast<unsigned char>(
ReplacementFor_c-'\t')<(0x298+1348-0x7d7)||ReplacementFor_c==
((char)(0x987+2166-0x11dd));}static inline bool ReplacementFor_isDigit(char 
ReplacementFor_c){return static_cast<unsigned char>(ReplacementFor_c-
((char)(0x4cd+3156-0x10f1)))<(0x1207+2143-0x1a5c);}static inline bool 
ReplacementFor_isUpper(char ReplacementFor_c){return static_cast<unsigned char>(
ReplacementFor_c-((char)(0x896+5416-0x1d7d)))<(0x40a+3911-0x1337);}static inline
 bool ReplacementFor_isLower(char ReplacementFor_c){return static_cast<unsigned 
char>(ReplacementFor_c-((char)(0x4a6+144-0x4d5)))<(0x37f+7308-0x1ff1);}static 
inline bool ReplacementFor_isOneOf(char ReplacementFor_c,const char*str){return 
strchr(str,ReplacementFor_c)!=nullptr;}void ReplacementFor_putBack(){--
ReplacementFor_head;}inline bool ReplacementFor_readChar(char&arg){if(
__builtin_expect(ReplacementFor_head>=ReplacementFor_tail,false)){
ReplacementFor_fillInput();if(__builtin_expect(ReplacementFor_head>=
ReplacementFor_tail,false))return arg='\0',false;}return arg=*
ReplacementFor_head++,true;}template<class ReplacementFor_UnaryPredicate>inline 
char ReplacementFor_skipCharacters(ReplacementFor_UnaryPredicate 
ReplacementFor_isSkipped){char ReplacementFor_c;do{ReplacementFor_c=nextChar();}
while(ReplacementFor_isSkipped(ReplacementFor_c));return ReplacementFor_c;}
inline char ReplacementFor_skipCharacters(){return ReplacementFor_skipCharacters
(ReplacementFor_isSpace);}template<class ReplacementFor_UnaryPredicate>inline 
int ReplacementFor_readString(char*arg,int ReplacementFor_limit,
ReplacementFor_UnaryPredicate ReplacementFor_isTerminator,bool 
ReplacementFor_skip){int ReplacementFor_charsRead=(0x722+6260-0x1f96);if(
ReplacementFor_skip)ReplacementFor_skipCharacters(ReplacementFor_isTerminator),
--ReplacementFor_head;for(--ReplacementFor_limit;ReplacementFor_head<
ReplacementFor_tail;ReplacementFor_fillInput()){ReplacementFor_ptrdiff_t 
chunkSize=ReplacementFor_find_if(ReplacementFor_head,min(ReplacementFor_tail,
ReplacementFor_head+ReplacementFor_limit-ReplacementFor_charsRead),
ReplacementFor_isTerminator)-ReplacementFor_head;arg=copy_n(ReplacementFor_head,
chunkSize,arg);ReplacementFor_head+=chunkSize;ReplacementFor_charsRead+=
chunkSize;if(chunkSize==(0x10c3+478-0x12a1)||ReplacementFor_head<
ReplacementFor_tail)break;}return*arg='\0',ReplacementFor_charsRead;}inline int 
ReplacementFor_readString(char*arg,int ReplacementFor_limit,const char*
ReplacementFor_terminators,bool ReplacementFor_skip){if(!*
ReplacementFor_terminators)return ReplacementFor_readString(arg,
ReplacementFor_limit,InputDevice::ReplacementFor_isSpace,ReplacementFor_skip);
return ReplacementFor_readString(arg,ReplacementFor_limit,[
ReplacementFor_terminators](char ReplacementFor_c){return InputDevice::
ReplacementFor_isOneOf(ReplacementFor_c,ReplacementFor_terminators);},
ReplacementFor_skip);}inline bool read(ReplacementFor_Detail::
ReplacementFor_Base ReplacementFor_newBase){ReplacementFor_base=
ReplacementFor_newBase.value;return true;}inline bool read(){return true;}inline
 bool read(char&arg){return ReplacementFor_readChar(arg);}template<class 
ReplacementFor_I>inline typename enable_if<is_integral<ReplacementFor_I>::value
&&ReplacementFor_is_unsigned<ReplacementFor_I>::value,bool>::type read(
ReplacementFor_I&arg){return ReplacementFor_readUnsignedInt(arg,
ReplacementFor_skipCharacters())>(0x74b+5523-0x1cde);}template<class 
ReplacementFor_I>inline typename enable_if<is_integral<ReplacementFor_I>::value
&&ReplacementFor_is_signed<ReplacementFor_I>::value,bool>::type read(
ReplacementFor_I&arg){return ReplacementFor_readSignedInt(arg,
ReplacementFor_skipCharacters());}template<class F>inline typename enable_if<
is_floating_point<F>::value,bool>::type read(F&arg){return 
ReplacementFor_readFloatingPoint(arg,ReplacementFor_skipCharacters());}inline 
bool read(const char&arg){ReplacementFor_skipCharacters([arg](char 
ReplacementFor_c){return arg!=ReplacementFor_c;});return true;}inline bool read(
const char*arg){if(*arg)ReplacementFor_skipCharacters([arg](char 
ReplacementFor_c){return InputDevice::ReplacementFor_isOneOf(ReplacementFor_c,
arg);});else ReplacementFor_skipCharacters();return ReplacementFor_putBack(),
true;}inline bool read(bool(*ReplacementFor_isSkipped)(char)){
ReplacementFor_skipCharacters(ReplacementFor_isSkipped);ReplacementFor_putBack()
;return true;}template<class ReplacementFor_I,class ReplacementFor_Terminator,
class...ReplacementFor_Ts>inline typename enable_if<is_integral<ReplacementFor_I
>::value,bool>::type read(char*arg,ReplacementFor_I ReplacementFor_limit,
ReplacementFor_Terminator ReplacementFor_terminator,ReplacementFor_Ts&&...
ReplacementFor_args){ReplacementFor_readString(arg,static_cast<int>(
ReplacementFor_limit),ReplacementFor_terminator,true);return read(forward<
ReplacementFor_Ts>(ReplacementFor_args)...);}template<class ReplacementFor_I>
inline typename enable_if<is_integral<ReplacementFor_I>::value,bool>::type read(
char*arg,ReplacementFor_I ReplacementFor_limit){return read(arg,
ReplacementFor_limit,"");}template<class...ReplacementFor_Ts>inline bool read(
char*first,char*last,ReplacementFor_Ts&&...ReplacementFor_args){return read(
first,static_cast<int>(last-first),forward<ReplacementFor_Ts>(
ReplacementFor_args)...);}template<int ReplacementFor_N,class...
ReplacementFor_Ts>inline bool read(char(&arg)[ReplacementFor_N],
ReplacementFor_Ts&&...ReplacementFor_args){return read(static_cast<char*>(arg),
ReplacementFor_N,forward<ReplacementFor_Ts>(ReplacementFor_args)...);}template<
class ReplacementFor_Terminator,class...ReplacementFor_Ts>inline bool read(
string&arg,ReplacementFor_Terminator ReplacementFor_terminator,ReplacementFor_Ts
&&...ReplacementFor_args){for(int length=max((0x1368+4762-0x25f2),static_cast<
int>(arg.capacity())),last=(0x1116+2069-0x192b);;length=last+=length){arg.resize
(last+length);int ReplacementFor_charsRead=ReplacementFor_readString(&arg[last],
length+(0x11e4+3256-0x1e9b),ReplacementFor_terminator,last==(0x7a3+3874-0x16c5))
;if(ReplacementFor_charsRead<length){arg.resize(last+ReplacementFor_charsRead);
return read(forward<ReplacementFor_Ts>(ReplacementFor_args)...);}}}inline bool 
read(string&arg){return read(arg,"");}template<class ReplacementFor_T1,class 
ReplacementFor_T2>inline bool read(pair<ReplacementFor_T1,ReplacementFor_T2>&arg
){return read(arg.first,arg.second);}template<class ReplacementFor_T>inline bool
 read(ReplacementFor_complex<ReplacementFor_T>&arg){ReplacementFor_T 
ReplacementFor_real,ReplacementFor_imag;if(!read(ReplacementFor_real,
ReplacementFor_imag))return false;arg.ReplacementFor_real(ReplacementFor_real),
arg.ReplacementFor_imag(ReplacementFor_imag);return true;}template<class 
ReplacementFor_T>inline bool read(vector<ReplacementFor_T>&arg){
ReplacementFor_uint ReplacementFor_n;if(!read(ReplacementFor_n))return false;arg
.resize(ReplacementFor_n);return read(arg.begin(),arg.end());}template<class 
ReplacementFor_Iterator,class...ReplacementFor_Ts>inline typename enable_if<
ReplacementFor_is_iterator<ReplacementFor_Iterator>::value,bool>::type read(
ReplacementFor_Iterator first,ReplacementFor_Iterator last,ReplacementFor_Ts&&
...ReplacementFor_args){for(;first!=last;++first)if(!read(*first))return false;
return read(forward<ReplacementFor_Ts>(ReplacementFor_args)...);}template<class 
ReplacementFor_Iterator,class ReplacementFor_I,class...ReplacementFor_Ts>inline 
typename enable_if<ReplacementFor_is_iterator<ReplacementFor_Iterator>::value&&
is_integral<ReplacementFor_I>::value,bool>::type read(ReplacementFor_Iterator 
first,ReplacementFor_I ReplacementFor_count,ReplacementFor_Ts&&...
ReplacementFor_args){return read(first,first+ReplacementFor_count,forward<
ReplacementFor_Ts>(ReplacementFor_args)...);}template<class ReplacementFor_T>
inline auto read(ReplacementFor_T&arg)->decltype(arg.read(*this)){return arg.
read(*this);}template<class ReplacementFor_T0,class ReplacementFor_T1,class...
ReplacementFor_Ts>inline typename enable_if<!ReplacementFor_is_iterator<
ReplacementFor_T0>::value&&!is_convertible<ReplacementFor_T0,char*>::value,bool>
::type read(ReplacementFor_T0&&ReplacementFor_arg0,ReplacementFor_T1&&
ReplacementFor_arg1,ReplacementFor_Ts&&...ReplacementFor_args){return read(
forward<ReplacementFor_T0>(ReplacementFor_arg0))&&read(forward<ReplacementFor_T1
>(ReplacementFor_arg1),forward<ReplacementFor_Ts>(ReplacementFor_args)...);}};
class ReplacementFor_InputFile:public InputDevice{FILE*file;bool 
ReplacementFor_lineBuffered;bool ReplacementFor_owner;char ReplacementFor_buffer
[ReplacementFor_BUFFER_SIZE];void ReplacementFor_fillInput()override{
ReplacementFor_head=ReplacementFor_buffer;*ReplacementFor_buffer='\0';if(
__builtin_expect(!ReplacementFor_lineBuffered,true)){ReplacementFor_tail=
ReplacementFor_head+fread(ReplacementFor_buffer,(0x18b8+2430-0x2235),
ReplacementFor_BUFFER_SIZE,file);}else{ReplacementFor_tail=ReplacementFor_head;
if(fgets(ReplacementFor_buffer,ReplacementFor_BUFFER_SIZE,file))while(*
ReplacementFor_tail)++ReplacementFor_tail;}}public:ReplacementFor_InputFile(FILE
*file=stdin,bool ReplacementFor_lineBuffered=true,bool 
ReplacementFor_takeOwnership=false):InputDevice(ReplacementFor_buffer,
ReplacementFor_buffer),file(file),ReplacementFor_lineBuffered(
ReplacementFor_lineBuffered),ReplacementFor_owner(ReplacementFor_takeOwnership){
}ReplacementFor_InputFile(const char*ReplacementFor_fileName):
ReplacementFor_InputFile(fopen(ReplacementFor_fileName,"\x72"),false,true){}~
ReplacementFor_InputFile(){if(ReplacementFor_owner)fclose(file);}};class 
ReplacementFor_InputString:public InputDevice{void ReplacementFor_fillInput()
override{while(*ReplacementFor_tail)++ReplacementFor_tail;}public:
ReplacementFor_InputString(const string&s):InputDevice(s.ReplacementFor_data(),s
.ReplacementFor_data()+s.size()){}ReplacementFor_InputString(const char*s):
InputDevice(s,s+strlen(s)){}};class ReplacementFor_OutputDevice{protected:char 
ReplacementFor_buffer[ReplacementFor_BUFFER_SIZE+ReplacementFor_MAX_LENGTH];char
*output;char*end;bool ReplacementFor_separate;ReplacementFor_OutputDevice():
output(ReplacementFor_buffer),end(ReplacementFor_buffer+
ReplacementFor_BUFFER_SIZE+ReplacementFor_MAX_LENGTH),ReplacementFor_separate(
false),ReplacementFor_width(ReplacementFor_setWidth().value),fill(
ReplacementFor_setFill().value),ReplacementFor_base(ReplacementFor_setBase().
value),precision(setPrecision().value),delimiter(ReplacementFor_setDelimiter().
value){ReplacementFor_computeBasePower();}virtual void 
ReplacementFor_writeToDevice(ReplacementFor_uint ReplacementFor_count)=0;inline 
void ReplacementFor_flushMaybe(){if(__builtin_expect(output>=
ReplacementFor_buffer+ReplacementFor_BUFFER_SIZE,false)){
ReplacementFor_writeToDevice(ReplacementFor_BUFFER_SIZE);output=copy(
ReplacementFor_buffer+ReplacementFor_BUFFER_SIZE,output,ReplacementFor_buffer);}
}void ReplacementFor_computeBasePower(){ReplacementFor_basePower=
(0x561+7223-0x2197);for(ReplacementFor_uint ReplacementFor_i=(0x488+1653-0xafd);
ReplacementFor_i<precision;++ReplacementFor_i)ReplacementFor_basePower*=
ReplacementFor_base;}template<class ReplacementFor_I>inline char*
ReplacementFor_writeUnsignedInt(ReplacementFor_I arg,char*last){if(
__builtin_expect(arg==(0x1606+2498-0x1fc8),false))*--last=
((char)(0x709+4162-0x171b));if(__builtin_expect(ReplacementFor_base==
(0x12cd+4394-0x23ed),true)){for(;arg;arg/=(0xe15+10-0xe15))*--last=
((char)(0x1803+2033-0x1fc4))+arg%(0x4f8+3486-0x128c);}else for(;arg;arg/=
ReplacementFor_base){ReplacementFor_I ReplacementFor_digit=arg%
ReplacementFor_base;*--last=ReplacementFor_digit<(0x87b+1445-0xe16)?
((char)(0x95+7322-0x1cff))+ReplacementFor_digit:((char)(0x2205+399-0x2353))-
(0x1389+3454-0x20fd)+ReplacementFor_digit;}return last;}template<class 
ReplacementFor_I>inline char*ReplacementFor_writeSignedInt(ReplacementFor_I arg,
char*last){auto unsignedArg=static_cast<typename make_unsigned<ReplacementFor_I>
::type>(arg);if(arg<(0xdcf+3201-0x1a50)){last=ReplacementFor_writeUnsignedInt(~
unsignedArg+(0xc75+2421-0x15e9),last);*--last=((char)(0xeda+3093-0x1ac2));return
 last;}return ReplacementFor_writeUnsignedInt(unsignedArg,last);}template<class 
F>char*ReplacementFor_writeFloatingPoint(F arg,char*last){bool 
ReplacementFor_negative=ReplacementFor_signbit(arg);if(ReplacementFor_negative)
arg=-arg;if(ReplacementFor_isnan(arg))for(int ReplacementFor_i=
(0x660+2097-0xe91);ReplacementFor_i<(0xd46+1330-0x1275);++ReplacementFor_i)*--
last=ReplacementFor_i["\x4e\x61\x4e"];else if(ReplacementFor_isinf(arg))for(int 
ReplacementFor_i=(0xaf9+6294-0x238f);ReplacementFor_i<(0x326+941-0x6d0);++
ReplacementFor_i)*--last=ReplacementFor_i["\x66\x6e\x49"];else{auto 
ReplacementFor_integerPart=static_cast<unsigned long long>(arg);auto 
ReplacementFor_fractionalPart=static_cast<unsigned long long>((arg-
ReplacementFor_integerPart)*ReplacementFor_basePower+F(0.5));if(
ReplacementFor_fractionalPart>=ReplacementFor_basePower)++
ReplacementFor_integerPart,ReplacementFor_fractionalPart=(0x4e7+8695-0x26de);
char*ReplacementFor_point=last-precision;if(precision>(0xba+3452-0xe36)){::fill(
ReplacementFor_point,ReplacementFor_writeUnsignedInt(
ReplacementFor_fractionalPart,last),((char)(0x158+4058-0x1102)));*--
ReplacementFor_point=((char)(0x4ab+4257-0x151e));}last=
ReplacementFor_writeUnsignedInt(ReplacementFor_integerPart,ReplacementFor_point)
;}if(ReplacementFor_negative)*--last=((char)(0x147b+1633-0x1aaf));return last;}
inline int ReplacementFor_writeT(char*first){int ReplacementFor_delimiterLength=
ReplacementFor_separate?ReplacementFor_writeDelimiter():(0x16c8+3993-0x2661);
ReplacementFor_separate=true;ReplacementFor_uint ReplacementFor_charsWritten=
static_cast<ReplacementFor_uint>(end-first);if(__builtin_expect(
ReplacementFor_charsWritten<ReplacementFor_width,false))
ReplacementFor_charsWritten+=writeFill(ReplacementFor_width-
ReplacementFor_charsWritten);output=copy(first,end,output);
ReplacementFor_flushMaybe();return ReplacementFor_delimiterLength+static_cast<
int>(ReplacementFor_charsWritten);}inline int writeFill(ReplacementFor_uint 
ReplacementFor_count){int ReplacementFor_charsWritten=static_cast<int>(
ReplacementFor_count);if(__builtin_expect(output+ReplacementFor_count+
ReplacementFor_MAX_LENGTH<end,true)){if(ReplacementFor_count==(0x144d+11-0x1457)
)*output++=fill;else output=ReplacementFor_fill_n(output,ReplacementFor_count,
fill);}else for(ReplacementFor_uint chunkSize=static_cast<ReplacementFor_uint>(
ReplacementFor_buffer+ReplacementFor_BUFFER_SIZE-output);;chunkSize=
ReplacementFor_BUFFER_SIZE){if(chunkSize>ReplacementFor_count)chunkSize=
ReplacementFor_count;output=ReplacementFor_fill_n(output,chunkSize,fill);
ReplacementFor_flushMaybe();if((ReplacementFor_count-=chunkSize)==
(0x2c4+3812-0x11a8))break;}return ReplacementFor_charsWritten;}public:
ReplacementFor_uint ReplacementFor_width;char fill;ReplacementFor_uint 
ReplacementFor_base;ReplacementFor_uint precision;unsigned long long 
ReplacementFor_basePower;string delimiter;ReplacementFor_OutputDevice(
ReplacementFor_OutputDevice const&)=delete;ReplacementFor_OutputDevice&operator=
(ReplacementFor_OutputDevice const&)=delete;virtual~ReplacementFor_OutputDevice(
){};inline int ReplacementFor_writeChar(char arg){ReplacementFor_separate=false;
*output++=arg;ReplacementFor_flushMaybe();return(0x581+2244-0xe44);}inline int 
ReplacementFor_writeString(const char*arg,size_t length,bool 
ReplacementFor_checkWidth=true){ReplacementFor_separate=false;
ReplacementFor_uint ReplacementFor_count=static_cast<ReplacementFor_uint>(length
);int ReplacementFor_charsWritten=static_cast<int>(ReplacementFor_count)+(
ReplacementFor_checkWidth&&ReplacementFor_count<ReplacementFor_width?writeFill(
ReplacementFor_width-ReplacementFor_count):(0x1e31+427-0x1fdc));if(
__builtin_expect(output+ReplacementFor_count+ReplacementFor_MAX_LENGTH<end,true)
){if(ReplacementFor_count==(0xca0+2274-0x1581))*output++=*arg;else output=copy_n
(arg,ReplacementFor_count,output);}else for(ReplacementFor_uint chunkSize=
static_cast<ReplacementFor_uint>(ReplacementFor_buffer+
ReplacementFor_BUFFER_SIZE-output);;chunkSize=ReplacementFor_BUFFER_SIZE){if(
chunkSize>ReplacementFor_count)chunkSize=ReplacementFor_count;output=copy_n(arg,
chunkSize,output);ReplacementFor_flushMaybe();if((ReplacementFor_count-=
chunkSize)==(0x1a18+1628-0x2074))break;arg+=chunkSize;}return 
ReplacementFor_charsWritten;}inline int ReplacementFor_writeDelimiter(){return 
ReplacementFor_writeString(delimiter.c_str(),delimiter.size(),false);}inline 
void ReplacementFor_flush(){ReplacementFor_writeToDevice(static_cast<
ReplacementFor_uint>(output-ReplacementFor_buffer));output=ReplacementFor_buffer
;}inline int write(ReplacementFor_Detail::ReplacementFor_Width 
ReplacementFor_newWidth){ReplacementFor_width=ReplacementFor_newWidth.value;
return(0xf7+7491-0x1e3a);}inline int write(ReplacementFor_Detail::Fill 
ReplacementFor_newFill){fill=ReplacementFor_newFill.value;return
(0x1200+5089-0x25e1);}inline int write(ReplacementFor_Detail::
ReplacementFor_Base ReplacementFor_newBase){ReplacementFor_base=
ReplacementFor_newBase.value;ReplacementFor_computeBasePower();return
(0x6a3+2733-0x1150);}inline int write(ReplacementFor_Detail::Precision 
ReplacementFor_newPrecision){precision=ReplacementFor_newPrecision.value;
ReplacementFor_computeBasePower();return(0x20b0+745-0x2399);}inline int write(
ReplacementFor_Detail::Delimiter ReplacementFor_newDelimiter){delimiter=
ReplacementFor_newDelimiter.value;return(0xf70+5668-0x2594);}inline int write(){
return(0x29a+1046-0x6b0);}inline int write(char arg){return 
ReplacementFor_writeChar(arg);}template<class ReplacementFor_I>inline typename 
enable_if<is_integral<ReplacementFor_I>::value&&ReplacementFor_is_unsigned<
ReplacementFor_I>::value,int>::type write(ReplacementFor_I arg){return 
ReplacementFor_writeT(ReplacementFor_writeUnsignedInt(arg,end));}template<class 
ReplacementFor_I>inline typename enable_if<is_integral<ReplacementFor_I>::value
&&ReplacementFor_is_signed<ReplacementFor_I>::value,int>::type write(
ReplacementFor_I arg){return ReplacementFor_writeT(ReplacementFor_writeSignedInt
(arg,end));}template<class F>inline typename enable_if<is_floating_point<F>::
value,int>::type write(F arg){return ReplacementFor_writeT(
ReplacementFor_writeFloatingPoint(arg,end));}inline int write(const char*arg){
return ReplacementFor_writeString(arg,strlen(arg));}template<int 
ReplacementFor_N>inline int write(char(&arg)[ReplacementFor_N]){return 
ReplacementFor_writeString(arg,strlen(arg));}inline int write(const string&arg){
return ReplacementFor_writeString(arg.c_str(),arg.size());}template<class 
ReplacementFor_T1,class ReplacementFor_T2>inline int write(const pair<
ReplacementFor_T1,ReplacementFor_T2>&arg){int ReplacementFor_charsWritten=write(
arg.first);ReplacementFor_charsWritten+=ReplacementFor_writeDelimiter();return 
ReplacementFor_charsWritten+write(arg.second);}template<class ReplacementFor_T>
inline int write(const ReplacementFor_complex<ReplacementFor_T>&arg){return 
write(ReplacementFor_real(arg),ReplacementFor_imag(arg));}template<class 
ReplacementFor_Iterator,class...ReplacementFor_Ts>inline typename enable_if<
ReplacementFor_is_iterator<ReplacementFor_Iterator>::value,int>::type write(
ReplacementFor_Iterator first,ReplacementFor_Iterator last,ReplacementFor_Ts&&
...ReplacementFor_args){int ReplacementFor_charsWritten=(0x21b+1243-0x6f6);for(;
first!=last;ReplacementFor_charsWritten+=++first==last?(0x1074+2348-0x19a0):
ReplacementFor_writeDelimiter())ReplacementFor_charsWritten+=write(*first);
return ReplacementFor_charsWritten+write(forward<ReplacementFor_Ts>(
ReplacementFor_args)...);}template<class ReplacementFor_Iterator,class 
ReplacementFor_I,class...ReplacementFor_Ts>inline typename enable_if<
ReplacementFor_is_iterator<ReplacementFor_Iterator>::value&&is_integral<
ReplacementFor_I>::value,int>::type write(ReplacementFor_Iterator first,
ReplacementFor_I ReplacementFor_count,ReplacementFor_Ts&&...ReplacementFor_args)
{return write(first,first+ReplacementFor_count,forward<ReplacementFor_Ts>(
ReplacementFor_args)...);}template<class ReplacementFor_T>inline auto write(
const ReplacementFor_T&arg)->decltype(arg.write(*this)){return arg.write(*this);
}template<class ReplacementFor_T0,class ReplacementFor_T1,class...
ReplacementFor_Ts>inline typename enable_if<!ReplacementFor_is_iterator<
ReplacementFor_T0>::value,int>::type write(ReplacementFor_T0&&
ReplacementFor_arg0,ReplacementFor_T1&&ReplacementFor_arg1,ReplacementFor_Ts&&
...ReplacementFor_args){int ReplacementFor_charsWritten=write(forward<
ReplacementFor_T0>(ReplacementFor_arg0));return ReplacementFor_charsWritten+
write(forward<ReplacementFor_T1>(ReplacementFor_arg1),forward<ReplacementFor_Ts>
(ReplacementFor_args)...);}};class ReplacementFor_OutputFile:public 
ReplacementFor_OutputDevice{FILE*file;bool ReplacementFor_owner;void 
ReplacementFor_writeToDevice(ReplacementFor_uint ReplacementFor_count)override{
fwrite(ReplacementFor_buffer,(0x635+1592-0xc6c),ReplacementFor_count,file);
fflush(file);}public:ReplacementFor_OutputFile(FILE*file=stdout,bool 
ReplacementFor_takeOwnership=false):file(file),ReplacementFor_owner(
ReplacementFor_takeOwnership){}ReplacementFor_OutputFile(const char*
ReplacementFor_fileName):ReplacementFor_OutputFile(fopen(ReplacementFor_fileName
,"\x77"),true){}~ReplacementFor_OutputFile()override{ReplacementFor_flush();if(
ReplacementFor_owner)fclose(file);}};class ReplacementFor_OutputString:public 
ReplacementFor_OutputDevice{string&str;void ReplacementFor_writeToDevice(
ReplacementFor_uint ReplacementFor_count)override{str.ReplacementFor_append(
ReplacementFor_buffer,ReplacementFor_count);}public:ReplacementFor_OutputString(
string&str):ReplacementFor_OutputDevice(),str(str){}~ReplacementFor_OutputString
()override{ReplacementFor_flush();}};ReplacementFor_unique_ptr<
ReplacementFor_InputFile>input;ReplacementFor_unique_ptr<
ReplacementFor_OutputFile>output;ReplacementFor_unique_ptr<
ReplacementFor_OutputFile>logs;template<class...ReplacementFor_Ts>inline void 
read(ReplacementFor_Ts&&...ReplacementFor_args){assert(input->read(forward<
ReplacementFor_Ts>(ReplacementFor_args)...));}template<class...ReplacementFor_Ts
>inline void ReplacementFor_writeln(ReplacementFor_Ts&&...ReplacementFor_args){
logs->write(forward<ReplacementFor_Ts>(ReplacementFor_args)...,'\n');logs->
ReplacementFor_flush();}class TestCase{public:static const int ReplacementFor_N=
1e5+(0xe95+3870-0x1dae);int ReplacementFor_n,ReplacementFor_r,ReplacementFor_o,
ReplacementFor_y,ReplacementFor_g,ReplacementFor_b,ReplacementFor_v;void input()
{read(ReplacementFor_n,ReplacementFor_r,ReplacementFor_o,ReplacementFor_y,
ReplacementFor_g,ReplacementFor_b,ReplacementFor_v);}void generate(bool 
ReplacementFor_big,int ReplacementFor_seed){auto rnd=bind(
ReplacementFor_uniform_int_distribution<int>((0x1ae3+2000-0x22b3),
(0x361+2086-0xb7e)),ReplacementFor_default_random_engine(ReplacementFor_seed));}
void solveSlow(){output->ReplacementFor_flush();}string ReplacementFor_work(){
string ReplacementFor_ans;if((0x763+7706-0x257b)*ReplacementFor_o==
ReplacementFor_n){if((0x10d8+2050-0x18d8)*ReplacementFor_b==ReplacementFor_n){
ReplacementFor_REP(ReplacementFor_i,ReplacementFor_o)ReplacementFor_ans+=
"\x4f\x42";}return ReplacementFor_ans;}if((0x1371+2609-0x1da0)*ReplacementFor_g
==ReplacementFor_n){if((0xddd+4581-0x1fc0)*ReplacementFor_r==ReplacementFor_n){
ReplacementFor_REP(ReplacementFor_i,ReplacementFor_g)ReplacementFor_ans+=
"\x47\x52";}return ReplacementFor_ans;}if((0x850+358-0x9b4)*ReplacementFor_v==
ReplacementFor_n){if((0xfed+2501-0x19b0)*ReplacementFor_y==ReplacementFor_n){
ReplacementFor_REP(ReplacementFor_i,ReplacementFor_v)ReplacementFor_ans+=
"\x56\x59";}return ReplacementFor_ans;}if((ReplacementFor_o>(0x106+8618-0x22b0)
&&ReplacementFor_b<=ReplacementFor_o)||(ReplacementFor_g>(0xfe2+3952-0x1f52)&&
ReplacementFor_r<=ReplacementFor_g)||(ReplacementFor_v>(0x13e9+4540-0x25a5)&&
ReplacementFor_y<=ReplacementFor_v))return ReplacementFor_ans;ReplacementFor_b-=
ReplacementFor_o;ReplacementFor_r-=ReplacementFor_g;ReplacementFor_y-=
ReplacementFor_v;if(ReplacementFor_b>=ReplacementFor_r){if(ReplacementFor_b>=
ReplacementFor_y){ReplacementFor_ans="\x42";--ReplacementFor_b;}else{
ReplacementFor_ans="\x59";--ReplacementFor_y;}}else{if(ReplacementFor_r>=
ReplacementFor_y){ReplacementFor_ans="\x52";--ReplacementFor_r;}else{
ReplacementFor_ans="\x59";--ReplacementFor_y;}}while(ReplacementFor_b>
(0x8c6+1944-0x105e)||ReplacementFor_r>(0x1adf+872-0x1e47)||ReplacementFor_y>
(0x666+859-0x9c1)){switch(ReplacementFor_ans.back()){case
((char)(0x340+3933-0x125b)):if(ReplacementFor_r+ReplacementFor_y==
(0x15f5+3373-0x2322))return{};if(ReplacementFor_r>ReplacementFor_y||
ReplacementFor_r==ReplacementFor_y&&ReplacementFor_ans[(0x65d+5844-0x1d31)]==
((char)(0x1389+4107-0x2342))){ReplacementFor_ans+=((char)(0x1e63+1878-0x2567));
--ReplacementFor_r;}else{ReplacementFor_ans+=((char)(0x2dc+3961-0x11fc));--
ReplacementFor_y;}break;case((char)(0x489+2999-0xfee)):if(ReplacementFor_b+
ReplacementFor_y==(0x98a+6381-0x2277))return{};if(ReplacementFor_b>
ReplacementFor_y||ReplacementFor_b==ReplacementFor_y&&ReplacementFor_ans[
(0x1936+2150-0x219c)]==((char)(0x9a3+5897-0x206a))){ReplacementFor_ans+=
((char)(0x21da+1199-0x2647));--ReplacementFor_b;}else{ReplacementFor_ans+=
((char)(0x3cc+8222-0x2391));--ReplacementFor_y;}break;case
((char)(0xfc5+1603-0x15af)):if(ReplacementFor_b+ReplacementFor_r==
(0x1b3+6477-0x1b00))return{};if(ReplacementFor_b>ReplacementFor_r||
ReplacementFor_b==ReplacementFor_r&&ReplacementFor_ans[(0xac4+6995-0x2617)]==
((char)(0x52+1249-0x4f1))){ReplacementFor_ans+=((char)(0x13ed+3541-0x2180));--
ReplacementFor_b;}else{ReplacementFor_ans+=((char)(0xc91+4523-0x1dea));--
ReplacementFor_r;}break;}}if(ReplacementFor_ans[(0x5d3+2719-0x1072)]==
ReplacementFor_ans.back())return{};string s;for(char ReplacementFor_c:
ReplacementFor_ans){s+=ReplacementFor_c;switch(ReplacementFor_c){case
((char)(0x1ca1+1718-0x2315)):ReplacementFor_REP(ReplacementFor_i,
ReplacementFor_o)s+="\x4f\x42";ReplacementFor_o=(0xadb+3711-0x195a);break;case
((char)(0xb25+3706-0x194d)):ReplacementFor_REP(ReplacementFor_i,ReplacementFor_g
)s+="\x47\x52";ReplacementFor_g=(0x840+5330-0x1d12);break;case
((char)(0x1c63+2002-0x23dc)):ReplacementFor_REP(ReplacementFor_i,
ReplacementFor_v)s+="\x56\x59";ReplacementFor_v=(0x5fa+6945-0x211b);break;}}
return s;}void solve(){string ReplacementFor_ans=ReplacementFor_work();if(
ReplacementFor_ans.empty())ReplacementFor_ans=
"\x49\x4d\x50\x4f\x53\x53\x49\x42\x4c\x45";write(ReplacementFor_ans);output->
ReplacementFor_flush();}string outputStr;TestCase():output(new 
ReplacementFor_OutputString(outputStr)){};private:ReplacementFor_unique_ptr<
ReplacementFor_OutputDevice>output;template<class...ReplacementFor_Ts>inline int
 write(ReplacementFor_Ts&&...ReplacementFor_args){return output->write(forward<
ReplacementFor_Ts>(ReplacementFor_args)...);}template<class...ReplacementFor_Ts>
inline int ReplacementFor_writeln(ReplacementFor_Ts&&...ReplacementFor_args){
return write(forward<ReplacementFor_Ts>(ReplacementFor_args)...,'\n');}};mutex 
inputMutex;int ReplacementFor_testIndex,ReplacementFor_testCount;vector<string>
answer;void ReplacementFor_work(){while(true){inputMutex.ReplacementFor_lock();
if(ReplacementFor_testIndex>=ReplacementFor_testCount){inputMutex.unlock();break
;}int ReplacementFor_current=ReplacementFor_testIndex++;ReplacementFor_writeln(
"\x43\x61\x73\x65\x20",ReplacementFor_current+(0x133+6798-0x1bc0),
"\x20\x73\x74\x61\x72\x74\x65\x64");ReplacementFor_unique_ptr<TestCase>test(new 
TestCase());test->input();inputMutex.unlock();test->solve();answer[
ReplacementFor_current].swap(test->outputStr);}}void ReplacementFor_writeAnswer(
int test,const string&answer){output->write("\x43\x61\x73\x65\x20\x23",test+
(0x151c+309-0x1650),"\x3a\x20",answer,"\n");output->ReplacementFor_flush();}void
 ReplacementFor_randomTest(){for(int ReplacementFor_i=(0x189a+3502-0x2648);
ReplacementFor_i<(0xa34+7411-0x26c3);++ReplacementFor_i){
ReplacementFor_unique_ptr<TestCase>test(new TestCase());test->generate(false,
ReplacementFor_i);test->solve();string output;output.swap(test->outputStr);test
->solveSlow();if(test->outputStr!=output){ReplacementFor_writeln(
"\x45\x72\x72\x6f\x72\x20\x6f\x6e\x20\x74\x65\x73\x74\x20\x23",ReplacementFor_i+
(0x88+2527-0xa66));ReplacementFor_writeln(
"\x45\x78\x70\x65\x63\x74\x65\x64\x3a" "\n",test->outputStr);
ReplacementFor_writeln("\x52\x65\x63\x65\x69\x76\x65\x64\x3a" "\n",output);}}
ReplacementFor_writeln("\n\n" "\x54\x65\x73\x74\x20\x74\x69\x6d\x65\x3a\x20",
static_cast<double>(clock())/CLOCKS_PER_SEC);exit((0x4ff+3676-0x135b));}void 
ReplacementFor_maxTest(){for(int ReplacementFor_i=(0xf7+9692-0x26d3);
ReplacementFor_i<(0x16a6+108-0x16ae);++ReplacementFor_i){
ReplacementFor_unique_ptr<TestCase>test(new TestCase());test->generate(true,
ReplacementFor_i);test->solve();ReplacementFor_writeAnswer(ReplacementFor_i,test
->outputStr);}ReplacementFor_writeln(
"\n\n" "\x54\x65\x73\x74\x20\x74\x69\x6d\x65\x3a\x20",static_cast<double>(clock(
))/CLOCKS_PER_SEC);exit((0x3f9+5868-0x1ae5));}int main(){input.
ReplacementFor_reset(new ReplacementFor_InputFile(
"\x42\x2d\x6c\x61\x72\x67\x65\x2e\x69\x6e"));output.ReplacementFor_reset(new 
ReplacementFor_OutputFile("\x6f\x75\x74\x70\x75\x74\x2e\x74\x78\x74"));logs.
ReplacementFor_reset(new ReplacementFor_OutputFile(stderr));logs->write(
setPrecision((0xac8+2287-0x13b3)));ReplacementFor_testIndex=(0x1aa2+866-0x1e04);
input->read(ReplacementFor_testCount);answer.resize(ReplacementFor_testCount);
#ifndef ReplacementFor_SINGLE_THREAD
vector<thread>threads;for(int ReplacementFor_i=(0x1729+3080-0x2331);
ReplacementFor_i<thread::hardware_concurrency();++ReplacementFor_i)threads.
emplace_back(ReplacementFor_work);for(auto&thread:threads)thread.join();for(int 
ReplacementFor_i=(0x5bc+4507-0x1757);ReplacementFor_i<ReplacementFor_testCount;
++ReplacementFor_i)ReplacementFor_writeAnswer(ReplacementFor_i,answer[
ReplacementFor_i]);
#else
for(int ReplacementFor_i=(0x393+6008-0x1b0b);ReplacementFor_i<
ReplacementFor_testCount;++ReplacementFor_i){ReplacementFor_writeln(
"\x43\x61\x73\x65\x20",ReplacementFor_i+(0x1af5+1621-0x2149),
"\x20\x73\x74\x61\x72\x74\x65\x64");ReplacementFor_unique_ptr<TestCase>test(new 
TestCase());test->input();test->solve();ReplacementFor_writeAnswer(
ReplacementFor_i,test->outputStr);}
#endif
ReplacementFor_writeln("\n\n" "\x54\x6f\x74\x61\x6c\x20\x74\x69\x6d\x65\x3a\x20"
,static_cast<double>(clock())/CLOCKS_PER_SEC);return(0x4aa+2733-0xf57);}
