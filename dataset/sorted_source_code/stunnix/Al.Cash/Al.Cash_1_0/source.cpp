
#define ASSERT(...) assert(ReplacementFor___VA_ARGS__)
#include <stdexcept>
#include <iostream>
#include <iomanip>
#include <sstream>
#include <fstream>
#include <cassert>
#include <cstring>
#include <cstdarg>
#include <cstdio>
#include <memory>
#include <random>
#include <cmath>
#include <ctime>
#include <unordered_map>
#include <unordered_set>
#include <functional>
#include <algorithm>
#include <complex>
#include <numeric>
#include <limits>
#include <bitset>
#include <vector>
#include <string>
#include <queue>
#include <deque>
#include <array>
#include <list>
#include <map>
#include <set>
#include <thread>
#include <mutex>
using namespace std;
#define ReplacementFor_all(a) (a).begin(), (a).end()
#define ReplacementFor_sz(a) static_cast<int>((a).size())
#define FOR(ReplacementFor_i, a, ReplacementFor_b) for (int ReplacementFor_i(a),\
 ReplacementFor_b_(ReplacementFor_b); ReplacementFor_i < ReplacementFor_b_; ++\
ReplacementFor_i)
#define ReplacementFor_REP(ReplacementFor_i, ReplacementFor_n) FOR (\
ReplacementFor_i, (0x42f+2865-0xf60), ReplacementFor_n)
#define ReplacementFor_FORD(ReplacementFor_i, a, ReplacementFor_b) for (int \
ReplacementFor_i(a), ReplacementFor_b_(ReplacementFor_b); ReplacementFor_i >= \
ReplacementFor_b_; --ReplacementFor_i)
#define UNIQUE(a) sort(ReplacementFor_all(a)), (a).ReplacementFor_erase(unique(\
ReplacementFor_all(a)), (a).end())
#define ReplacementFor_CL(a, ReplacementFor_v) memset(a, ReplacementFor_v, \
sizeof a)
#define ReplacementFor_eb emplace_back
#define ReplacementFor_pb push_back
#define ReplacementFor_X first
#define ReplacementFor_Y second
typedef long long ReplacementFor_ll;typedef long double ReplacementFor_ld;
typedef vector<int>ReplacementFor_vi;typedef pair<int,int>ReplacementFor_pii;
template<class ReplacementFor_T>using ReplacementFor_min_queue=priority_queue<
ReplacementFor_T,vector<ReplacementFor_T>,greater<ReplacementFor_T>>;const int 
ReplacementFor_INF=static_cast<int>(1e9);const long long ReplacementFor_INF_LL=
static_cast<long long>(4e18);const double ReplacementFor_pi=acos(-1.0);template<
class ReplacementFor_T>ReplacementFor_T&ReplacementFor_smin(ReplacementFor_T&
ReplacementFor_x,const ReplacementFor_T&ReplacementFor_y){if(ReplacementFor_x>
ReplacementFor_y)ReplacementFor_x=ReplacementFor_y;return ReplacementFor_x;}
template<class ReplacementFor_T>ReplacementFor_T&ReplacementFor_smax(
ReplacementFor_T&ReplacementFor_x,const ReplacementFor_T&ReplacementFor_y){if(
ReplacementFor_x<ReplacementFor_y)ReplacementFor_x=ReplacementFor_y;return 
ReplacementFor_x;}template<class ReplacementFor_T>ReplacementFor_T 
ReplacementFor_sqr(const ReplacementFor_T&ReplacementFor_x){return 
ReplacementFor_x*ReplacementFor_x;}template<class ReplacementFor_T>inline int 
ReplacementFor_sgn(const ReplacementFor_T&ReplacementFor_x){return(
ReplacementFor_T((0x1756+3127-0x238d))<ReplacementFor_x)-(ReplacementFor_x<
ReplacementFor_T((0xee7+1996-0x16b3)));}template<class ReplacementFor_T>
ReplacementFor_T ReplacementFor_gcd(ReplacementFor_T a,ReplacementFor_T 
ReplacementFor_b){for(a=ReplacementFor_abs(a),ReplacementFor_b=
ReplacementFor_abs(ReplacementFor_b);a&&ReplacementFor_b;a>=ReplacementFor_b?a%=
ReplacementFor_b:ReplacementFor_b%=a);return a+ReplacementFor_b;}template<class 
ReplacementFor_T>struct ReplacementFor_is_commutative{constexpr static bool 
value=true;};template<class ReplacementFor_T>struct ReplacementFor_is_iterator{
template<class ReplacementFor_U,typename enable_if<!is_convertible<
ReplacementFor_U,const char*>::value,int>::type=(0x1a00+152-0x1a98)>constexpr 
static auto ReplacementFor_has_indirection(int)->decltype(*declval<
ReplacementFor_U>(),bool()){return true;}template<class>constexpr static bool 
ReplacementFor_has_indirection(long){return false;}constexpr static bool value=
ReplacementFor_has_indirection<ReplacementFor_T>((0x4bf+2965-0x1054));};using 
ReplacementFor_uint=unsigned int;const ReplacementFor_uint 
ReplacementFor_BUFFER_SIZE=(0xa1c+3350-0x1731)<<(0x10e1+167-0x117c);const 
ReplacementFor_uint ReplacementFor_MAX_LENGTH=(0xf39+153-0xfd1)<<
(0x57c+8597-0x270a);namespace ReplacementFor_Detail{struct ReplacementFor_Width{
ReplacementFor_uint value;};struct Fill{char value;};struct ReplacementFor_Base{
ReplacementFor_uint value;};struct Precision{ReplacementFor_uint value;};struct 
Delimiter{const char*value;};}ReplacementFor_Detail::ReplacementFor_Width 
ReplacementFor_setWidth(ReplacementFor_uint value=(0x1079+3531-0x1e44)){return{
value};}ReplacementFor_Detail::Fill ReplacementFor_setFill(char value=
((char)(0xa83+676-0xd07))){return{value};}ReplacementFor_Detail::
ReplacementFor_Base ReplacementFor_setBase(ReplacementFor_uint value=
(0xe58+6322-0x2700)){assert((0xa24+4309-0x1af7)<=value&&value<=
(0x7c2+4744-0x1a26));return{value};}ReplacementFor_Detail::Precision 
setPrecision(ReplacementFor_uint value=(0x464+5394-0x196d)){assert(value<
ReplacementFor_MAX_LENGTH);return{value};}ReplacementFor_Detail::Delimiter 
ReplacementFor_setDelimiter(const char*value="\x20"){return{value};}class 
InputDevice{protected:const char*ReplacementFor_head;const char*
ReplacementFor_tail;InputDevice(const char*ReplacementFor_head,const char*
ReplacementFor_tail):ReplacementFor_head(ReplacementFor_head),
ReplacementFor_tail(ReplacementFor_tail),ReplacementFor_base(
ReplacementFor_setBase().value){}virtual void ReplacementFor_fillInput()=0;
inline char nextChar(){if(__builtin_expect(ReplacementFor_head>=
ReplacementFor_tail,false))ReplacementFor_fillInput();return*ReplacementFor_head
++;}template<class ReplacementFor_I>int ReplacementFor_readUnsignedIntGeneral(
ReplacementFor_I&arg,char ReplacementFor_c){ReplacementFor_I value=
(0x926+6100-0x20fa);int length=(0x87f+1228-0xd4b);for(;;++length,
ReplacementFor_c=nextChar()){if(ReplacementFor_isDigit(ReplacementFor_c))
ReplacementFor_c-=((char)(0xb4d+1872-0x126d));else if(ReplacementFor_isUpper(
ReplacementFor_c))ReplacementFor_c-=((char)(0x3ba+2552-0xd71))-
(0x791+5360-0x1c77);else if(ReplacementFor_isLower(ReplacementFor_c))
ReplacementFor_c-=((char)(0xdf6+2295-0x168c))-(0x379+6822-0x1e15);else 
ReplacementFor_c=ReplacementFor_base;if(ReplacementFor_c>=ReplacementFor_base)
break;value=ReplacementFor_base*value+ReplacementFor_c;}arg=value;return--
ReplacementFor_head,length;}template<class ReplacementFor_I>inline int 
ReplacementFor_readUnsignedInt(ReplacementFor_I&arg,char ReplacementFor_c){if(
__builtin_expect(ReplacementFor_base>(0x511+7065-0x20a0),false))return 
ReplacementFor_readUnsignedIntGeneral(arg,ReplacementFor_c);ReplacementFor_I 
value=(0x681+475-0x85c);int length=(0x13b+4668-0x1377);for(;static_cast<unsigned
 char>(ReplacementFor_c-((char)(0x3e8+4764-0x1654)))<ReplacementFor_base;++
length,ReplacementFor_c=nextChar())value=ReplacementFor_base*value+
ReplacementFor_c-((char)(0x478+6069-0x1bfd));arg=value;return--
ReplacementFor_head,length;}template<class ReplacementFor_I>inline bool 
ReplacementFor_readSignedInt(ReplacementFor_I&arg,char ReplacementFor_c){bool 
ReplacementFor_negative=ReplacementFor_c==((char)(0x470+5422-0x1971));if(
ReplacementFor_negative)ReplacementFor_c=nextChar();typename make_unsigned<
ReplacementFor_I>::type unsignedArg;if(ReplacementFor_readUnsignedInt(
unsignedArg,ReplacementFor_c)==(0xb8b+3003-0x1746))return false;arg=
ReplacementFor_negative?~static_cast<ReplacementFor_I>(unsignedArg-
(0x1631+3544-0x2408)):static_cast<ReplacementFor_I>(unsignedArg);return true;}
template<class F>bool ReplacementFor_readFloatingPoint(F&arg,char 
ReplacementFor_c){bool ReplacementFor_negative=ReplacementFor_c==
((char)(0x4e8+7562-0x2245));if(ReplacementFor_negative)ReplacementFor_c=nextChar
();unsigned long long ReplacementFor_integerPart;if(
ReplacementFor_readUnsignedInt(ReplacementFor_integerPart,ReplacementFor_c)==
(0x3e5+7376-0x20b5))return false;arg=static_cast<F>(ReplacementFor_integerPart);
if(nextChar()==((char)(0x3f9+5424-0x18fb))){unsigned long long 
ReplacementFor_fractionalPart=(0x4cd+746-0x7b7);int 
ReplacementFor_fractionalLength=ReplacementFor_readUnsignedInt(
ReplacementFor_fractionalPart,nextChar());if(ReplacementFor_fractionalLength>
(0xc9+1915-0x844)){unsigned long long ReplacementFor_basePower=
(0x1952+2574-0x235f);for(;ReplacementFor_fractionalLength;--
ReplacementFor_fractionalLength)ReplacementFor_basePower*=ReplacementFor_base;
arg+=static_cast<F>(ReplacementFor_fractionalPart)/ReplacementFor_basePower;}}
else--ReplacementFor_head;if(ReplacementFor_negative)arg=-arg;return true;}
public:ReplacementFor_uint ReplacementFor_base;InputDevice(InputDevice const&)=
delete;InputDevice&operator=(InputDevice const&)=delete;static inline bool 
ReplacementFor_isSpace(char ReplacementFor_c){return static_cast<unsigned char>(
ReplacementFor_c-'\t')<(0x119b+3755-0x2041)||ReplacementFor_c==
((char)(0x1101+948-0x1495));}static inline bool ReplacementFor_isDigit(char 
ReplacementFor_c){return static_cast<unsigned char>(ReplacementFor_c-
((char)(0x9f2+6122-0x21ac)))<(0x5d5+5139-0x19de);}static inline bool 
ReplacementFor_isUpper(char ReplacementFor_c){return static_cast<unsigned char>(
ReplacementFor_c-((char)(0x16c7+3412-0x23da)))<(0x19a5+3389-0x26c8);}static 
inline bool ReplacementFor_isLower(char ReplacementFor_c){return static_cast<
unsigned char>(ReplacementFor_c-((char)(0x128b+871-0x1591)))<(0xce2+3583-0x1ac7)
;}static inline bool ReplacementFor_isOneOf(char ReplacementFor_c,const char*str
){return strchr(str,ReplacementFor_c)!=nullptr;}void ReplacementFor_putBack(){--
ReplacementFor_head;}inline bool ReplacementFor_readChar(char&arg){if(
__builtin_expect(ReplacementFor_head>=ReplacementFor_tail,false)){
ReplacementFor_fillInput();if(__builtin_expect(ReplacementFor_head>=
ReplacementFor_tail,false))return arg='\0',false;}return arg=*
ReplacementFor_head++,true;}template<class ReplacementFor_UnaryPredicate>inline 
char ReplacementFor_skipCharacters(ReplacementFor_UnaryPredicate 
ReplacementFor_isSkipped){char ReplacementFor_c;do{ReplacementFor_c=nextChar();}
while(ReplacementFor_isSkipped(ReplacementFor_c));return ReplacementFor_c;}
inline char ReplacementFor_skipCharacters(){return ReplacementFor_skipCharacters
(ReplacementFor_isSpace);}template<class ReplacementFor_UnaryPredicate>inline 
int ReplacementFor_readString(char*arg,int ReplacementFor_limit,
ReplacementFor_UnaryPredicate ReplacementFor_isTerminator,bool 
ReplacementFor_skip){int ReplacementFor_charsRead=(0x438+7501-0x2185);if(
ReplacementFor_skip)ReplacementFor_skipCharacters(ReplacementFor_isTerminator),
--ReplacementFor_head;for(--ReplacementFor_limit;ReplacementFor_head<
ReplacementFor_tail;ReplacementFor_fillInput()){ReplacementFor_ptrdiff_t 
chunkSize=ReplacementFor_find_if(ReplacementFor_head,min(ReplacementFor_tail,
ReplacementFor_head+ReplacementFor_limit-ReplacementFor_charsRead),
ReplacementFor_isTerminator)-ReplacementFor_head;arg=copy_n(ReplacementFor_head,
chunkSize,arg);ReplacementFor_head+=chunkSize;ReplacementFor_charsRead+=
chunkSize;if(chunkSize==(0x3c9+1620-0xa1d)||ReplacementFor_head<
ReplacementFor_tail)break;}return*arg='\0',ReplacementFor_charsRead;}inline int 
ReplacementFor_readString(char*arg,int ReplacementFor_limit,const char*
ReplacementFor_terminators,bool ReplacementFor_skip){if(!*
ReplacementFor_terminators)return ReplacementFor_readString(arg,
ReplacementFor_limit,InputDevice::ReplacementFor_isSpace,ReplacementFor_skip);
return ReplacementFor_readString(arg,ReplacementFor_limit,[
ReplacementFor_terminators](char ReplacementFor_c){return InputDevice::
ReplacementFor_isOneOf(ReplacementFor_c,ReplacementFor_terminators);},
ReplacementFor_skip);}inline bool read(ReplacementFor_Detail::
ReplacementFor_Base ReplacementFor_newBase){ReplacementFor_base=
ReplacementFor_newBase.value;return true;}inline bool read(){return true;}inline
 bool read(char&arg){return ReplacementFor_readChar(arg);}template<class 
ReplacementFor_I>inline typename enable_if<is_integral<ReplacementFor_I>::value
&&ReplacementFor_is_unsigned<ReplacementFor_I>::value,bool>::type read(
ReplacementFor_I&arg){return ReplacementFor_readUnsignedInt(arg,
ReplacementFor_skipCharacters())>(0x251b+249-0x2614);}template<class 
ReplacementFor_I>inline typename enable_if<is_integral<ReplacementFor_I>::value
&&ReplacementFor_is_signed<ReplacementFor_I>::value,bool>::type read(
ReplacementFor_I&arg){return ReplacementFor_readSignedInt(arg,
ReplacementFor_skipCharacters());}template<class F>inline typename enable_if<
is_floating_point<F>::value,bool>::type read(F&arg){return 
ReplacementFor_readFloatingPoint(arg,ReplacementFor_skipCharacters());}inline 
bool read(const char&arg){ReplacementFor_skipCharacters([arg](char 
ReplacementFor_c){return arg!=ReplacementFor_c;});return true;}inline bool read(
const char*arg){if(*arg)ReplacementFor_skipCharacters([arg](char 
ReplacementFor_c){return InputDevice::ReplacementFor_isOneOf(ReplacementFor_c,
arg);});else ReplacementFor_skipCharacters();return ReplacementFor_putBack(),
true;}inline bool read(bool(*ReplacementFor_isSkipped)(char)){
ReplacementFor_skipCharacters(ReplacementFor_isSkipped);ReplacementFor_putBack()
;return true;}template<class ReplacementFor_I,class ReplacementFor_Terminator,
class...ReplacementFor_Ts>inline typename enable_if<is_integral<ReplacementFor_I
>::value,bool>::type read(char*arg,ReplacementFor_I ReplacementFor_limit,
ReplacementFor_Terminator ReplacementFor_terminator,ReplacementFor_Ts&&...
ReplacementFor_args){ReplacementFor_readString(arg,static_cast<int>(
ReplacementFor_limit),ReplacementFor_terminator,true);return read(forward<
ReplacementFor_Ts>(ReplacementFor_args)...);}template<class ReplacementFor_I>
inline typename enable_if<is_integral<ReplacementFor_I>::value,bool>::type read(
char*arg,ReplacementFor_I ReplacementFor_limit){return read(arg,
ReplacementFor_limit,"");}template<class...ReplacementFor_Ts>inline bool read(
char*first,char*last,ReplacementFor_Ts&&...ReplacementFor_args){return read(
first,static_cast<int>(last-first),forward<ReplacementFor_Ts>(
ReplacementFor_args)...);}template<int ReplacementFor_N,class...
ReplacementFor_Ts>inline bool read(char(&arg)[ReplacementFor_N],
ReplacementFor_Ts&&...ReplacementFor_args){return read(static_cast<char*>(arg),
ReplacementFor_N,forward<ReplacementFor_Ts>(ReplacementFor_args)...);}template<
class ReplacementFor_Terminator,class...ReplacementFor_Ts>inline bool read(
string&arg,ReplacementFor_Terminator ReplacementFor_terminator,ReplacementFor_Ts
&&...ReplacementFor_args){for(int length=max((0x3d3+386-0x545),static_cast<int>(
arg.capacity())),last=(0x1de5+871-0x214c);;length=last+=length){arg.resize(last+
length);int ReplacementFor_charsRead=ReplacementFor_readString(&arg[last],length
+(0x433+1274-0x92c),ReplacementFor_terminator,last==(0xde3+2867-0x1916));if(
ReplacementFor_charsRead<length){arg.resize(last+ReplacementFor_charsRead);
return read(forward<ReplacementFor_Ts>(ReplacementFor_args)...);}}}inline bool 
read(string&arg){return read(arg,"");}template<class ReplacementFor_T1,class 
ReplacementFor_T2>inline bool read(pair<ReplacementFor_T1,ReplacementFor_T2>&arg
){return read(arg.first,arg.second);}template<class ReplacementFor_T>inline bool
 read(ReplacementFor_complex<ReplacementFor_T>&arg){ReplacementFor_T 
ReplacementFor_real,ReplacementFor_imag;if(!read(ReplacementFor_real,
ReplacementFor_imag))return false;arg.ReplacementFor_real(ReplacementFor_real),
arg.ReplacementFor_imag(ReplacementFor_imag);return true;}template<class 
ReplacementFor_T>inline bool read(vector<ReplacementFor_T>&arg){
ReplacementFor_uint ReplacementFor_n;if(!read(ReplacementFor_n))return false;arg
.resize(ReplacementFor_n);return read(arg.begin(),arg.end());}template<class 
ReplacementFor_Iterator,class...ReplacementFor_Ts>inline typename enable_if<
ReplacementFor_is_iterator<ReplacementFor_Iterator>::value,bool>::type read(
ReplacementFor_Iterator first,ReplacementFor_Iterator last,ReplacementFor_Ts&&
...ReplacementFor_args){for(;first!=last;++first)if(!read(*first))return false;
return read(forward<ReplacementFor_Ts>(ReplacementFor_args)...);}template<class 
ReplacementFor_Iterator,class ReplacementFor_I,class...ReplacementFor_Ts>inline 
typename enable_if<ReplacementFor_is_iterator<ReplacementFor_Iterator>::value&&
is_integral<ReplacementFor_I>::value,bool>::type read(ReplacementFor_Iterator 
first,ReplacementFor_I ReplacementFor_count,ReplacementFor_Ts&&...
ReplacementFor_args){return read(first,first+ReplacementFor_count,forward<
ReplacementFor_Ts>(ReplacementFor_args)...);}template<class ReplacementFor_T>
inline auto read(ReplacementFor_T&arg)->decltype(arg.read(*this)){return arg.
read(*this);}template<class ReplacementFor_T0,class ReplacementFor_T1,class...
ReplacementFor_Ts>inline typename enable_if<!ReplacementFor_is_iterator<
ReplacementFor_T0>::value&&!is_convertible<ReplacementFor_T0,char*>::value,bool>
::type read(ReplacementFor_T0&&ReplacementFor_arg0,ReplacementFor_T1&&
ReplacementFor_arg1,ReplacementFor_Ts&&...ReplacementFor_args){return read(
forward<ReplacementFor_T0>(ReplacementFor_arg0))&&read(forward<ReplacementFor_T1
>(ReplacementFor_arg1),forward<ReplacementFor_Ts>(ReplacementFor_args)...);}};
class ReplacementFor_InputFile:public InputDevice{FILE*file;bool 
ReplacementFor_lineBuffered;bool ReplacementFor_owner;char ReplacementFor_buffer
[ReplacementFor_BUFFER_SIZE];void ReplacementFor_fillInput()override{
ReplacementFor_head=ReplacementFor_buffer;*ReplacementFor_buffer='\0';if(
__builtin_expect(!ReplacementFor_lineBuffered,true)){ReplacementFor_tail=
ReplacementFor_head+fread(ReplacementFor_buffer,(0x599+6877-0x2075),
ReplacementFor_BUFFER_SIZE,file);}else{ReplacementFor_tail=ReplacementFor_head;
if(fgets(ReplacementFor_buffer,ReplacementFor_BUFFER_SIZE,file))while(*
ReplacementFor_tail)++ReplacementFor_tail;}}public:ReplacementFor_InputFile(FILE
*file=stdin,bool ReplacementFor_lineBuffered=true,bool 
ReplacementFor_takeOwnership=false):InputDevice(ReplacementFor_buffer,
ReplacementFor_buffer),file(file),ReplacementFor_lineBuffered(
ReplacementFor_lineBuffered),ReplacementFor_owner(ReplacementFor_takeOwnership){
}ReplacementFor_InputFile(const char*ReplacementFor_fileName):
ReplacementFor_InputFile(fopen(ReplacementFor_fileName,"\x72"),false,true){}~
ReplacementFor_InputFile(){if(ReplacementFor_owner)fclose(file);}};class 
ReplacementFor_InputString:public InputDevice{void ReplacementFor_fillInput()
override{while(*ReplacementFor_tail)++ReplacementFor_tail;}public:
ReplacementFor_InputString(const string&s):InputDevice(s.ReplacementFor_data(),s
.ReplacementFor_data()+s.size()){}ReplacementFor_InputString(const char*s):
InputDevice(s,s+strlen(s)){}};class ReplacementFor_OutputDevice{protected:char 
ReplacementFor_buffer[ReplacementFor_BUFFER_SIZE+ReplacementFor_MAX_LENGTH];char
*output;char*end;bool ReplacementFor_separate;ReplacementFor_OutputDevice():
output(ReplacementFor_buffer),end(ReplacementFor_buffer+
ReplacementFor_BUFFER_SIZE+ReplacementFor_MAX_LENGTH),ReplacementFor_separate(
false),ReplacementFor_width(ReplacementFor_setWidth().value),fill(
ReplacementFor_setFill().value),ReplacementFor_base(ReplacementFor_setBase().
value),precision(setPrecision().value),delimiter(ReplacementFor_setDelimiter().
value){ReplacementFor_computeBasePower();}virtual void 
ReplacementFor_writeToDevice(ReplacementFor_uint ReplacementFor_count)=0;inline 
void ReplacementFor_flushMaybe(){if(__builtin_expect(output>=
ReplacementFor_buffer+ReplacementFor_BUFFER_SIZE,false)){
ReplacementFor_writeToDevice(ReplacementFor_BUFFER_SIZE);output=copy(
ReplacementFor_buffer+ReplacementFor_BUFFER_SIZE,output,ReplacementFor_buffer);}
}void ReplacementFor_computeBasePower(){ReplacementFor_basePower=
(0x11b7+2616-0x1bee);for(ReplacementFor_uint ReplacementFor_i=(0x5b1+501-0x7a6);
ReplacementFor_i<precision;++ReplacementFor_i)ReplacementFor_basePower*=
ReplacementFor_base;}template<class ReplacementFor_I>inline char*
ReplacementFor_writeUnsignedInt(ReplacementFor_I arg,char*last){if(
__builtin_expect(arg==(0x5bf+2283-0xeaa),false))*--last=
((char)(0x8c7+2117-0x10dc));if(__builtin_expect(ReplacementFor_base==
(0x1f1+3665-0x1038),true)){for(;arg;arg/=(0x4e6+48-0x50c))*--last=
((char)(0x1c09+1847-0x2310))+arg%(0x1a77+2471-0x2414);}else for(;arg;arg/=
ReplacementFor_base){ReplacementFor_I ReplacementFor_digit=arg%
ReplacementFor_base;*--last=ReplacementFor_digit<(0x115c+4537-0x230b)?
((char)(0x1e3+27-0x1ce))+ReplacementFor_digit:((char)(0x446+1346-0x947))-
(0xb37+278-0xc43)+ReplacementFor_digit;}return last;}template<class 
ReplacementFor_I>inline char*ReplacementFor_writeSignedInt(ReplacementFor_I arg,
char*last){auto unsignedArg=static_cast<typename make_unsigned<ReplacementFor_I>
::type>(arg);if(arg<(0xa48+2729-0x14f1)){last=ReplacementFor_writeUnsignedInt(~
unsignedArg+(0x287+962-0x648),last);*--last=((char)(0x544+1563-0xb32));return 
last;}return ReplacementFor_writeUnsignedInt(unsignedArg,last);}template<class F
>char*ReplacementFor_writeFloatingPoint(F arg,char*last){bool 
ReplacementFor_negative=ReplacementFor_signbit(arg);if(ReplacementFor_negative)
arg=-arg;if(ReplacementFor_isnan(arg))for(int ReplacementFor_i=
(0x60d+1416-0xb95);ReplacementFor_i<(0x4a3+8766-0x26de);++ReplacementFor_i)*--
last=ReplacementFor_i["\x4e\x61\x4e"];else if(ReplacementFor_isinf(arg))for(int 
ReplacementFor_i=(0x118d+4099-0x2190);ReplacementFor_i<(0x279+2037-0xa6b);++
ReplacementFor_i)*--last=ReplacementFor_i["\x66\x6e\x49"];else{auto 
ReplacementFor_integerPart=static_cast<unsigned long long>(arg);auto 
ReplacementFor_fractionalPart=static_cast<unsigned long long>((arg-
ReplacementFor_integerPart)*ReplacementFor_basePower+F(0.5));if(
ReplacementFor_fractionalPart>=ReplacementFor_basePower)++
ReplacementFor_integerPart,ReplacementFor_fractionalPart=(0x227f+450-0x2441);
char*ReplacementFor_point=last-precision;if(precision>(0x645+4064-0x1625)){::
fill(ReplacementFor_point,ReplacementFor_writeUnsignedInt(
ReplacementFor_fractionalPart,last),((char)(0x4a1+4983-0x17e8)));*--
ReplacementFor_point=((char)(0x704+7914-0x25c0));}last=
ReplacementFor_writeUnsignedInt(ReplacementFor_integerPart,ReplacementFor_point)
;}if(ReplacementFor_negative)*--last=((char)(0x1e8+824-0x4f3));return last;}
inline int ReplacementFor_writeT(char*first){int ReplacementFor_delimiterLength=
ReplacementFor_separate?ReplacementFor_writeDelimiter():(0xe8c+1702-0x1532);
ReplacementFor_separate=true;ReplacementFor_uint ReplacementFor_charsWritten=
static_cast<ReplacementFor_uint>(end-first);if(__builtin_expect(
ReplacementFor_charsWritten<ReplacementFor_width,false))
ReplacementFor_charsWritten+=writeFill(ReplacementFor_width-
ReplacementFor_charsWritten);output=copy(first,end,output);
ReplacementFor_flushMaybe();return ReplacementFor_delimiterLength+static_cast<
int>(ReplacementFor_charsWritten);}inline int writeFill(ReplacementFor_uint 
ReplacementFor_count){int ReplacementFor_charsWritten=static_cast<int>(
ReplacementFor_count);if(__builtin_expect(output+ReplacementFor_count+
ReplacementFor_MAX_LENGTH<end,true)){if(ReplacementFor_count==(0x6bf+2068-0xed2)
)*output++=fill;else output=ReplacementFor_fill_n(output,ReplacementFor_count,
fill);}else for(ReplacementFor_uint chunkSize=static_cast<ReplacementFor_uint>(
ReplacementFor_buffer+ReplacementFor_BUFFER_SIZE-output);;chunkSize=
ReplacementFor_BUFFER_SIZE){if(chunkSize>ReplacementFor_count)chunkSize=
ReplacementFor_count;output=ReplacementFor_fill_n(output,chunkSize,fill);
ReplacementFor_flushMaybe();if((ReplacementFor_count-=chunkSize)==
(0x1613+3788-0x24df))break;}return ReplacementFor_charsWritten;}public:
ReplacementFor_uint ReplacementFor_width;char fill;ReplacementFor_uint 
ReplacementFor_base;ReplacementFor_uint precision;unsigned long long 
ReplacementFor_basePower;string delimiter;ReplacementFor_OutputDevice(
ReplacementFor_OutputDevice const&)=delete;ReplacementFor_OutputDevice&operator=
(ReplacementFor_OutputDevice const&)=delete;virtual~ReplacementFor_OutputDevice(
){};inline int ReplacementFor_writeChar(char arg){ReplacementFor_separate=false;
*output++=arg;ReplacementFor_flushMaybe();return(0x96b+5282-0x1e0c);}inline int 
ReplacementFor_writeString(const char*arg,size_t length,bool 
ReplacementFor_checkWidth=true){ReplacementFor_separate=false;
ReplacementFor_uint ReplacementFor_count=static_cast<ReplacementFor_uint>(length
);int ReplacementFor_charsWritten=static_cast<int>(ReplacementFor_count)+(
ReplacementFor_checkWidth&&ReplacementFor_count<ReplacementFor_width?writeFill(
ReplacementFor_width-ReplacementFor_count):(0x17c8+3045-0x23ad));if(
__builtin_expect(output+ReplacementFor_count+ReplacementFor_MAX_LENGTH<end,true)
){if(ReplacementFor_count==(0x10ff+4302-0x21cc))*output++=*arg;else output=
copy_n(arg,ReplacementFor_count,output);}else for(ReplacementFor_uint chunkSize=
static_cast<ReplacementFor_uint>(ReplacementFor_buffer+
ReplacementFor_BUFFER_SIZE-output);;chunkSize=ReplacementFor_BUFFER_SIZE){if(
chunkSize>ReplacementFor_count)chunkSize=ReplacementFor_count;output=copy_n(arg,
chunkSize,output);ReplacementFor_flushMaybe();if((ReplacementFor_count-=
chunkSize)==(0x1951+977-0x1d22))break;arg+=chunkSize;}return 
ReplacementFor_charsWritten;}inline int ReplacementFor_writeDelimiter(){return 
ReplacementFor_writeString(delimiter.c_str(),delimiter.size(),false);}inline 
void ReplacementFor_flush(){ReplacementFor_writeToDevice(static_cast<
ReplacementFor_uint>(output-ReplacementFor_buffer));output=ReplacementFor_buffer
;}inline int write(ReplacementFor_Detail::ReplacementFor_Width 
ReplacementFor_newWidth){ReplacementFor_width=ReplacementFor_newWidth.value;
return(0x1085+1434-0x161f);}inline int write(ReplacementFor_Detail::Fill 
ReplacementFor_newFill){fill=ReplacementFor_newFill.value;return
(0x3ea+1123-0x84d);}inline int write(ReplacementFor_Detail::ReplacementFor_Base 
ReplacementFor_newBase){ReplacementFor_base=ReplacementFor_newBase.value;
ReplacementFor_computeBasePower();return(0x2d9+3577-0x10d2);}inline int write(
ReplacementFor_Detail::Precision ReplacementFor_newPrecision){precision=
ReplacementFor_newPrecision.value;ReplacementFor_computeBasePower();return
(0xf9a+1510-0x1580);}inline int write(ReplacementFor_Detail::Delimiter 
ReplacementFor_newDelimiter){delimiter=ReplacementFor_newDelimiter.value;return
(0x9b8+3279-0x1687);}inline int write(){return(0x5b1+3180-0x121d);}inline int 
write(char arg){return ReplacementFor_writeChar(arg);}template<class 
ReplacementFor_I>inline typename enable_if<is_integral<ReplacementFor_I>::value
&&ReplacementFor_is_unsigned<ReplacementFor_I>::value,int>::type write(
ReplacementFor_I arg){return ReplacementFor_writeT(
ReplacementFor_writeUnsignedInt(arg,end));}template<class ReplacementFor_I>
inline typename enable_if<is_integral<ReplacementFor_I>::value&&
ReplacementFor_is_signed<ReplacementFor_I>::value,int>::type write(
ReplacementFor_I arg){return ReplacementFor_writeT(ReplacementFor_writeSignedInt
(arg,end));}template<class F>inline typename enable_if<is_floating_point<F>::
value,int>::type write(F arg){return ReplacementFor_writeT(
ReplacementFor_writeFloatingPoint(arg,end));}inline int write(const char*arg){
return ReplacementFor_writeString(arg,strlen(arg));}template<int 
ReplacementFor_N>inline int write(char(&arg)[ReplacementFor_N]){return 
ReplacementFor_writeString(arg,strlen(arg));}inline int write(const string&arg){
return ReplacementFor_writeString(arg.c_str(),arg.size());}template<class 
ReplacementFor_T1,class ReplacementFor_T2>inline int write(const pair<
ReplacementFor_T1,ReplacementFor_T2>&arg){int ReplacementFor_charsWritten=write(
arg.first);ReplacementFor_charsWritten+=ReplacementFor_writeDelimiter();return 
ReplacementFor_charsWritten+write(arg.second);}template<class ReplacementFor_T>
inline int write(const ReplacementFor_complex<ReplacementFor_T>&arg){return 
write(ReplacementFor_real(arg),ReplacementFor_imag(arg));}template<class 
ReplacementFor_Iterator,class...ReplacementFor_Ts>inline typename enable_if<
ReplacementFor_is_iterator<ReplacementFor_Iterator>::value,int>::type write(
ReplacementFor_Iterator first,ReplacementFor_Iterator last,ReplacementFor_Ts&&
...ReplacementFor_args){int ReplacementFor_charsWritten=(0x200+261-0x305);for(;
first!=last;ReplacementFor_charsWritten+=++first==last?(0x3ff+4475-0x157a):
ReplacementFor_writeDelimiter())ReplacementFor_charsWritten+=write(*first);
return ReplacementFor_charsWritten+write(forward<ReplacementFor_Ts>(
ReplacementFor_args)...);}template<class ReplacementFor_Iterator,class 
ReplacementFor_I,class...ReplacementFor_Ts>inline typename enable_if<
ReplacementFor_is_iterator<ReplacementFor_Iterator>::value&&is_integral<
ReplacementFor_I>::value,int>::type write(ReplacementFor_Iterator first,
ReplacementFor_I ReplacementFor_count,ReplacementFor_Ts&&...ReplacementFor_args)
{return write(first,first+ReplacementFor_count,forward<ReplacementFor_Ts>(
ReplacementFor_args)...);}template<class ReplacementFor_T>inline auto write(
const ReplacementFor_T&arg)->decltype(arg.write(*this)){return arg.write(*this);
}template<class ReplacementFor_T0,class ReplacementFor_T1,class...
ReplacementFor_Ts>inline typename enable_if<!ReplacementFor_is_iterator<
ReplacementFor_T0>::value,int>::type write(ReplacementFor_T0&&
ReplacementFor_arg0,ReplacementFor_T1&&ReplacementFor_arg1,ReplacementFor_Ts&&
...ReplacementFor_args){int ReplacementFor_charsWritten=write(forward<
ReplacementFor_T0>(ReplacementFor_arg0));return ReplacementFor_charsWritten+
write(forward<ReplacementFor_T1>(ReplacementFor_arg1),forward<ReplacementFor_Ts>
(ReplacementFor_args)...);}};class ReplacementFor_OutputFile:public 
ReplacementFor_OutputDevice{FILE*file;bool ReplacementFor_owner;void 
ReplacementFor_writeToDevice(ReplacementFor_uint ReplacementFor_count)override{
fwrite(ReplacementFor_buffer,(0x91a+206-0x9e7),ReplacementFor_count,file);fflush
(file);}public:ReplacementFor_OutputFile(FILE*file=stdout,bool 
ReplacementFor_takeOwnership=false):file(file),ReplacementFor_owner(
ReplacementFor_takeOwnership){}ReplacementFor_OutputFile(const char*
ReplacementFor_fileName):ReplacementFor_OutputFile(fopen(ReplacementFor_fileName
,"\x77"),true){}~ReplacementFor_OutputFile()override{ReplacementFor_flush();if(
ReplacementFor_owner)fclose(file);}};class ReplacementFor_OutputString:public 
ReplacementFor_OutputDevice{string&str;void ReplacementFor_writeToDevice(
ReplacementFor_uint ReplacementFor_count)override{str.ReplacementFor_append(
ReplacementFor_buffer,ReplacementFor_count);}public:ReplacementFor_OutputString(
string&str):ReplacementFor_OutputDevice(),str(str){}~ReplacementFor_OutputString
()override{ReplacementFor_flush();}};ReplacementFor_unique_ptr<
ReplacementFor_InputFile>input;ReplacementFor_unique_ptr<
ReplacementFor_OutputFile>output;ReplacementFor_unique_ptr<
ReplacementFor_OutputFile>logs;template<class...ReplacementFor_Ts>inline void 
read(ReplacementFor_Ts&&...ReplacementFor_args){assert(input->read(forward<
ReplacementFor_Ts>(ReplacementFor_args)...));}template<class...ReplacementFor_Ts
>inline void ReplacementFor_writeln(ReplacementFor_Ts&&...ReplacementFor_args){
logs->write(forward<ReplacementFor_Ts>(ReplacementFor_args)...,'\n');logs->
ReplacementFor_flush();}class TestCase{public:static const int ReplacementFor_N=
1e5+(0x6d3+2963-0x1261);int ReplacementFor_n,ReplacementFor_r,ReplacementFor_o,
ReplacementFor_y,ReplacementFor_g,ReplacementFor_b,ReplacementFor_v;void input()
{read(ReplacementFor_n,ReplacementFor_r,ReplacementFor_o,ReplacementFor_y,
ReplacementFor_g,ReplacementFor_b,ReplacementFor_v);}void generate(bool 
ReplacementFor_big,int ReplacementFor_seed){auto rnd=bind(
ReplacementFor_uniform_int_distribution<int>((0xf8b+4727-0x2202),
(0x1359+4890-0x266a)),ReplacementFor_default_random_engine(ReplacementFor_seed))
;}void solveSlow(){output->ReplacementFor_flush();}string ReplacementFor_work(){
string ReplacementFor_ans;if((0x7d4+3690-0x163c)*ReplacementFor_o==
ReplacementFor_n){if((0xafb+3134-0x1737)*ReplacementFor_b==ReplacementFor_n){
ReplacementFor_REP(ReplacementFor_i,ReplacementFor_o)ReplacementFor_ans+=
"\x4f\x42";}return ReplacementFor_ans;}if((0x1294+296-0x13ba)*ReplacementFor_g==
ReplacementFor_n){if((0x482+1277-0x97d)*ReplacementFor_r==ReplacementFor_n){
ReplacementFor_REP(ReplacementFor_i,ReplacementFor_g)ReplacementFor_ans+=
"\x47\x52";}return ReplacementFor_ans;}if((0xa88+1836-0x11b2)*ReplacementFor_v==
ReplacementFor_n){if((0xc5c+5860-0x233e)*ReplacementFor_y==ReplacementFor_n){
ReplacementFor_REP(ReplacementFor_i,ReplacementFor_v)ReplacementFor_ans+=
"\x56\x59";}return ReplacementFor_ans;}if((ReplacementFor_o>(0x67+2214-0x90d)&&
ReplacementFor_b<=ReplacementFor_o)||(ReplacementFor_g>(0x1ce1+1478-0x22a7)&&
ReplacementFor_r<=ReplacementFor_g)||(ReplacementFor_v>(0x13bf+666-0x1659)&&
ReplacementFor_y<=ReplacementFor_v))return ReplacementFor_ans;ReplacementFor_b-=
ReplacementFor_o;ReplacementFor_r-=ReplacementFor_g;ReplacementFor_y-=
ReplacementFor_v;if(ReplacementFor_b>=ReplacementFor_r){if(ReplacementFor_b>=
ReplacementFor_y){ReplacementFor_ans="\x42";--ReplacementFor_b;}else{
ReplacementFor_ans="\x59";--ReplacementFor_y;}}else{if(ReplacementFor_r>=
ReplacementFor_y){ReplacementFor_ans="\x52";--ReplacementFor_r;}else{
ReplacementFor_ans="\x59";--ReplacementFor_y;}}while(ReplacementFor_b>
(0x17c1+352-0x1921)||ReplacementFor_r>(0xd8f+1307-0x12aa)||ReplacementFor_y>
(0x898+6826-0x2342)){switch(ReplacementFor_ans.back()){case
((char)(0x1237+3644-0x2031)):if(ReplacementFor_r+ReplacementFor_y==
(0x706+3260-0x13c2))return{};if(ReplacementFor_r>ReplacementFor_y||
ReplacementFor_r==ReplacementFor_y&&ReplacementFor_ans[(0x171d+2012-0x1ef9)]==
((char)(0x355+5584-0x18d3))){ReplacementFor_ans+=((char)(0xff5+268-0x10af));--
ReplacementFor_r;}else{ReplacementFor_ans+=((char)(0xa9c+3636-0x1877));--
ReplacementFor_y;}break;case((char)(0x3d5+789-0x698)):if(ReplacementFor_b+
ReplacementFor_y==(0x356+1332-0x88a))return{};if(ReplacementFor_b>
ReplacementFor_y||ReplacementFor_b==ReplacementFor_y&&ReplacementFor_ans[
(0x49b+756-0x78f)]==((char)(0x770+5051-0x1ae9))){ReplacementFor_ans+=
((char)(0xc33+3009-0x17b2));--ReplacementFor_b;}else{ReplacementFor_ans+=
((char)(0x14bf+1979-0x1c21));--ReplacementFor_y;}break;case
((char)(0x29b+8802-0x24a4)):if(ReplacementFor_b+ReplacementFor_r==
(0x746+6640-0x2136))return{};if(ReplacementFor_b>ReplacementFor_r||
ReplacementFor_b==ReplacementFor_r&&ReplacementFor_ans[(0xa37+4994-0x1db9)]==
((char)(0x1b3a+2547-0x24eb))){ReplacementFor_ans+=((char)(0x7b5+2801-0x1264));--
ReplacementFor_b;}else{ReplacementFor_ans+=((char)(0x18c9+591-0x1ac6));--
ReplacementFor_r;}break;}}if(ReplacementFor_ans[(0xb1+3104-0xcd1)]==
ReplacementFor_ans.back())return{};string s;for(char ReplacementFor_c:
ReplacementFor_ans){s+=ReplacementFor_c;switch(ReplacementFor_c){case
((char)(0x13d5+3945-0x22fc)):ReplacementFor_REP(ReplacementFor_i,
ReplacementFor_o)s+="\x4f\x42";ReplacementFor_o=(0x1911+2021-0x20f6);break;case
((char)(0x59f+158-0x5eb)):ReplacementFor_REP(ReplacementFor_i,ReplacementFor_g)s
+="\x47\x52";ReplacementFor_g=(0x4b8+7363-0x217b);break;case
((char)(0xe17+1158-0x1244)):ReplacementFor_REP(ReplacementFor_i,ReplacementFor_v
)s+="\x56\x59";ReplacementFor_v=(0x230c+468-0x24e0);break;}}return s;}void solve
(){string ReplacementFor_ans=ReplacementFor_work();if(ReplacementFor_ans.empty()
)ReplacementFor_ans="\x49\x4d\x50\x4f\x53\x53\x49\x42\x4c\x45";write(
ReplacementFor_ans);output->ReplacementFor_flush();}string outputStr;TestCase():
output(new ReplacementFor_OutputString(outputStr)){};private:
ReplacementFor_unique_ptr<ReplacementFor_OutputDevice>output;template<class...
ReplacementFor_Ts>inline int write(ReplacementFor_Ts&&...ReplacementFor_args){
return output->write(forward<ReplacementFor_Ts>(ReplacementFor_args)...);}
template<class...ReplacementFor_Ts>inline int ReplacementFor_writeln(
ReplacementFor_Ts&&...ReplacementFor_args){return write(forward<
ReplacementFor_Ts>(ReplacementFor_args)...,'\n');}};mutex inputMutex;int 
ReplacementFor_testIndex,ReplacementFor_testCount;vector<string>answer;void 
ReplacementFor_work(){while(true){inputMutex.ReplacementFor_lock();if(
ReplacementFor_testIndex>=ReplacementFor_testCount){inputMutex.unlock();break;}
int ReplacementFor_current=ReplacementFor_testIndex++;ReplacementFor_writeln(
"\x43\x61\x73\x65\x20",ReplacementFor_current+(0x1180+1337-0x16b8),
"\x20\x73\x74\x61\x72\x74\x65\x64");ReplacementFor_unique_ptr<TestCase>test(new 
TestCase());test->input();inputMutex.unlock();test->solve();answer[
ReplacementFor_current].swap(test->outputStr);}}void ReplacementFor_writeAnswer(
int test,const string&answer){output->write("\x43\x61\x73\x65\x20\x23",test+
(0x12f1+1178-0x178a),"\x3a\x20",answer,"\n");output->ReplacementFor_flush();}
void ReplacementFor_randomTest(){for(int ReplacementFor_i=(0x1af9+1198-0x1fa7);
ReplacementFor_i<(0xd2c+5304-0x2180);++ReplacementFor_i){
ReplacementFor_unique_ptr<TestCase>test(new TestCase());test->generate(false,
ReplacementFor_i);test->solve();string output;output.swap(test->outputStr);test
->solveSlow();if(test->outputStr!=output){ReplacementFor_writeln(
"\x45\x72\x72\x6f\x72\x20\x6f\x6e\x20\x74\x65\x73\x74\x20\x23",ReplacementFor_i+
(0x77f+2963-0x1311));ReplacementFor_writeln(
"\x45\x78\x70\x65\x63\x74\x65\x64\x3a" "\n",test->outputStr);
ReplacementFor_writeln("\x52\x65\x63\x65\x69\x76\x65\x64\x3a" "\n",output);}}
ReplacementFor_writeln("\n\n" "\x54\x65\x73\x74\x20\x74\x69\x6d\x65\x3a\x20",
static_cast<double>(clock())/CLOCKS_PER_SEC);exit((0x12a3+2216-0x1b4b));}void 
ReplacementFor_maxTest(){for(int ReplacementFor_i=(0xbf3+404-0xd87);
ReplacementFor_i<(0xfc6+5871-0x2651);++ReplacementFor_i){
ReplacementFor_unique_ptr<TestCase>test(new TestCase());test->generate(true,
ReplacementFor_i);test->solve();ReplacementFor_writeAnswer(ReplacementFor_i,test
->outputStr);}ReplacementFor_writeln(
"\n\n" "\x54\x65\x73\x74\x20\x74\x69\x6d\x65\x3a\x20",static_cast<double>(clock(
))/CLOCKS_PER_SEC);exit((0xa01+1666-0x1083));}int main(){input.
ReplacementFor_reset(new ReplacementFor_InputFile(
"\x42\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x30\x2e\x69\x6e"))
;output.ReplacementFor_reset(new ReplacementFor_OutputFile(
"\x6f\x75\x74\x70\x75\x74\x2e\x74\x78\x74"));logs.ReplacementFor_reset(new 
ReplacementFor_OutputFile(stderr));logs->write(setPrecision((0x757+6895-0x2242))
);ReplacementFor_testIndex=(0x2490+23-0x24a7);input->read(
ReplacementFor_testCount);answer.resize(ReplacementFor_testCount);
#ifndef ReplacementFor_SINGLE_THREAD
vector<thread>threads;for(int ReplacementFor_i=(0xcd1+2153-0x153a);
ReplacementFor_i<thread::hardware_concurrency();++ReplacementFor_i)threads.
emplace_back(ReplacementFor_work);for(auto&thread:threads)thread.join();for(int 
ReplacementFor_i=(0x189+8423-0x2270);ReplacementFor_i<ReplacementFor_testCount;
++ReplacementFor_i)ReplacementFor_writeAnswer(ReplacementFor_i,answer[
ReplacementFor_i]);
#else
for(int ReplacementFor_i=(0xdb7+3416-0x1b0f);ReplacementFor_i<
ReplacementFor_testCount;++ReplacementFor_i){ReplacementFor_writeln(
"\x43\x61\x73\x65\x20",ReplacementFor_i+(0x1bd8+1398-0x214d),
"\x20\x73\x74\x61\x72\x74\x65\x64");ReplacementFor_unique_ptr<TestCase>test(new 
TestCase());test->input();test->solve();ReplacementFor_writeAnswer(
ReplacementFor_i,test->outputStr);}
#endif
ReplacementFor_writeln("\n\n" "\x54\x6f\x74\x61\x6c\x20\x74\x69\x6d\x65\x3a\x20"
,static_cast<double>(clock())/CLOCKS_PER_SEC);return(0xdec+771-0x10ef);}
