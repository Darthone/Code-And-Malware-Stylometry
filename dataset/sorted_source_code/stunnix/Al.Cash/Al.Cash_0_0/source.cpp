
#define ASSERT(...) assert(ReplacementFor___VA_ARGS__)
#include <stdexcept>
#include <iostream>
#include <iomanip>
#include <sstream>
#include <fstream>
#include <cassert>
#include <cstring>
#include <cstdarg>
#include <cstdio>
#include <memory>
#include <random>
#include <cmath>
#include <ctime>
#include <unordered_map>
#include <unordered_set>
#include <functional>
#include <algorithm>
#include <complex>
#include <numeric>
#include <limits>
#include <bitset>
#include <vector>
#include <string>
#include <queue>
#include <deque>
#include <array>
#include <list>
#include <map>
#include <set>
#include <thread>
#include <mutex>
using namespace std;
#define ReplacementFor_all(a) (a).begin(), (a).end()
#define ReplacementFor_sz(a) static_cast<int>((a).size())
#define FOR(ReplacementFor_i, a, ReplacementFor_b) for (int ReplacementFor_i(a),\
 ReplacementFor_b_(ReplacementFor_b); ReplacementFor_i < ReplacementFor_b_; ++\
ReplacementFor_i)
#define ReplacementFor_REP(ReplacementFor_i, ReplacementFor_n) FOR (\
ReplacementFor_i, (0x734+6433-0x2055), ReplacementFor_n)
#define ReplacementFor_FORD(ReplacementFor_i, a, ReplacementFor_b) for (int \
ReplacementFor_i(a), ReplacementFor_b_(ReplacementFor_b); ReplacementFor_i >= \
ReplacementFor_b_; --ReplacementFor_i)
#define UNIQUE(a) sort(ReplacementFor_all(a)), (a).ReplacementFor_erase(unique(\
ReplacementFor_all(a)), (a).end())
#define ReplacementFor_CL(a, ReplacementFor_v) memset(a, ReplacementFor_v, \
sizeof a)
#define ReplacementFor_eb emplace_back
#define ReplacementFor_pb push_back
#define ReplacementFor_X first
#define ReplacementFor_Y second
typedef long long ReplacementFor_ll;typedef long double ReplacementFor_ld;
typedef vector<int>ReplacementFor_vi;typedef pair<int,int>ReplacementFor_pii;
template<class ReplacementFor_T>using ReplacementFor_min_queue=priority_queue<
ReplacementFor_T,vector<ReplacementFor_T>,greater<ReplacementFor_T>>;const int 
ReplacementFor_INF=static_cast<int>(1e9);const long long ReplacementFor_INF_LL=
static_cast<long long>(4e18);const double ReplacementFor_pi=acos(-1.0);template<
class ReplacementFor_T>ReplacementFor_T&ReplacementFor_smin(ReplacementFor_T&
ReplacementFor_x,const ReplacementFor_T&ReplacementFor_y){if(ReplacementFor_x>
ReplacementFor_y)ReplacementFor_x=ReplacementFor_y;return ReplacementFor_x;}
template<class ReplacementFor_T>ReplacementFor_T&ReplacementFor_smax(
ReplacementFor_T&ReplacementFor_x,const ReplacementFor_T&ReplacementFor_y){if(
ReplacementFor_x<ReplacementFor_y)ReplacementFor_x=ReplacementFor_y;return 
ReplacementFor_x;}template<class ReplacementFor_T>ReplacementFor_T 
ReplacementFor_sqr(const ReplacementFor_T&ReplacementFor_x){return 
ReplacementFor_x*ReplacementFor_x;}template<class ReplacementFor_T>inline int 
ReplacementFor_sgn(const ReplacementFor_T&ReplacementFor_x){return(
ReplacementFor_T((0x10b7+5239-0x252e))<ReplacementFor_x)-(ReplacementFor_x<
ReplacementFor_T((0x267+2265-0xb40)));}template<class ReplacementFor_T>
ReplacementFor_T ReplacementFor_gcd(ReplacementFor_T a,ReplacementFor_T 
ReplacementFor_b){for(a=ReplacementFor_abs(a),ReplacementFor_b=
ReplacementFor_abs(ReplacementFor_b);a&&ReplacementFor_b;a>=ReplacementFor_b?a%=
ReplacementFor_b:ReplacementFor_b%=a);return a+ReplacementFor_b;}template<class 
ReplacementFor_T>struct ReplacementFor_is_commutative{constexpr static bool 
value=true;};template<class ReplacementFor_T>struct ReplacementFor_is_iterator{
template<class ReplacementFor_U,typename enable_if<!is_convertible<
ReplacementFor_U,const char*>::value,int>::type=(0x1562+2850-0x2084)>constexpr 
static auto ReplacementFor_has_indirection(int)->decltype(*declval<
ReplacementFor_U>(),bool()){return true;}template<class>constexpr static bool 
ReplacementFor_has_indirection(long){return false;}constexpr static bool value=
ReplacementFor_has_indirection<ReplacementFor_T>((0x258+4571-0x1433));};using 
ReplacementFor_uint=unsigned int;const ReplacementFor_uint 
ReplacementFor_BUFFER_SIZE=(0xa7a+4865-0x1d7a)<<(0x1e32+607-0x2085);const 
ReplacementFor_uint ReplacementFor_MAX_LENGTH=(0x87b+5522-0x1e0c)<<
(0x4e7+3343-0x11ef);namespace ReplacementFor_Detail{struct ReplacementFor_Width{
ReplacementFor_uint value;};struct Fill{char value;};struct ReplacementFor_Base{
ReplacementFor_uint value;};struct Precision{ReplacementFor_uint value;};struct 
Delimiter{const char*value;};}ReplacementFor_Detail::ReplacementFor_Width 
ReplacementFor_setWidth(ReplacementFor_uint value=(0xc25+126-0xca3)){return{
value};}ReplacementFor_Detail::Fill ReplacementFor_setFill(char value=
((char)(0x570+6169-0x1d69))){return{value};}ReplacementFor_Detail::
ReplacementFor_Base ReplacementFor_setBase(ReplacementFor_uint value=
(0x23+3053-0xc06)){assert((0x87a+1658-0xef2)<=value&&value<=(0x307+5653-0x18f8))
;return{value};}ReplacementFor_Detail::Precision setPrecision(
ReplacementFor_uint value=(0xf28+3345-0x1c30)){assert(value<
ReplacementFor_MAX_LENGTH);return{value};}ReplacementFor_Detail::Delimiter 
ReplacementFor_setDelimiter(const char*value="\x20"){return{value};}class 
InputDevice{protected:const char*ReplacementFor_head;const char*
ReplacementFor_tail;InputDevice(const char*ReplacementFor_head,const char*
ReplacementFor_tail):ReplacementFor_head(ReplacementFor_head),
ReplacementFor_tail(ReplacementFor_tail),ReplacementFor_base(
ReplacementFor_setBase().value){}virtual void ReplacementFor_fillInput()=0;
inline char nextChar(){if(__builtin_expect(ReplacementFor_head>=
ReplacementFor_tail,false))ReplacementFor_fillInput();return*ReplacementFor_head
++;}template<class ReplacementFor_I>int ReplacementFor_readUnsignedIntGeneral(
ReplacementFor_I&arg,char ReplacementFor_c){ReplacementFor_I value=
(0x1193+2123-0x19de);int length=(0x2f1+7851-0x219c);for(;;++length,
ReplacementFor_c=nextChar()){if(ReplacementFor_isDigit(ReplacementFor_c))
ReplacementFor_c-=((char)(0x1162+1827-0x1855));else if(ReplacementFor_isUpper(
ReplacementFor_c))ReplacementFor_c-=((char)(0xe71+4999-0x21b7))-
(0x1881+2992-0x2427);else if(ReplacementFor_isLower(ReplacementFor_c))
ReplacementFor_c-=((char)(0x1ef+7942-0x2094))-(0xfb7+1616-0x15fd);else 
ReplacementFor_c=ReplacementFor_base;if(ReplacementFor_c>=ReplacementFor_base)
break;value=ReplacementFor_base*value+ReplacementFor_c;}arg=value;return--
ReplacementFor_head,length;}template<class ReplacementFor_I>inline int 
ReplacementFor_readUnsignedInt(ReplacementFor_I&arg,char ReplacementFor_c){if(
__builtin_expect(ReplacementFor_base>(0x301+9205-0x26ec),false))return 
ReplacementFor_readUnsignedIntGeneral(arg,ReplacementFor_c);ReplacementFor_I 
value=(0x159d+1370-0x1af7);int length=(0x1e0b+509-0x2008);for(;static_cast<
unsigned char>(ReplacementFor_c-((char)(0x3a0+7263-0x1fcf)))<ReplacementFor_base
;++length,ReplacementFor_c=nextChar())value=ReplacementFor_base*value+
ReplacementFor_c-((char)(0x5d6+7216-0x21d6));arg=value;return--
ReplacementFor_head,length;}template<class ReplacementFor_I>inline bool 
ReplacementFor_readSignedInt(ReplacementFor_I&arg,char ReplacementFor_c){bool 
ReplacementFor_negative=ReplacementFor_c==((char)(0x1a0+2481-0xb24));if(
ReplacementFor_negative)ReplacementFor_c=nextChar();typename make_unsigned<
ReplacementFor_I>::type unsignedArg;if(ReplacementFor_readUnsignedInt(
unsignedArg,ReplacementFor_c)==(0x132+7670-0x1f28))return false;arg=
ReplacementFor_negative?~static_cast<ReplacementFor_I>(unsignedArg-
(0x2c8+901-0x64c)):static_cast<ReplacementFor_I>(unsignedArg);return true;}
template<class F>bool ReplacementFor_readFloatingPoint(F&arg,char 
ReplacementFor_c){bool ReplacementFor_negative=ReplacementFor_c==
((char)(0xfa2+2630-0x19bb));if(ReplacementFor_negative)ReplacementFor_c=nextChar
();unsigned long long ReplacementFor_integerPart;if(
ReplacementFor_readUnsignedInt(ReplacementFor_integerPart,ReplacementFor_c)==
(0x1768+2434-0x20ea))return false;arg=static_cast<F>(ReplacementFor_integerPart)
;if(nextChar()==((char)(0x8ba+4712-0x1af4))){unsigned long long 
ReplacementFor_fractionalPart=(0x187+699-0x442);int 
ReplacementFor_fractionalLength=ReplacementFor_readUnsignedInt(
ReplacementFor_fractionalPart,nextChar());if(ReplacementFor_fractionalLength>
(0x1c9b+526-0x1ea9)){unsigned long long ReplacementFor_basePower=
(0x394+7542-0x2109);for(;ReplacementFor_fractionalLength;--
ReplacementFor_fractionalLength)ReplacementFor_basePower*=ReplacementFor_base;
arg+=static_cast<F>(ReplacementFor_fractionalPart)/ReplacementFor_basePower;}}
else--ReplacementFor_head;if(ReplacementFor_negative)arg=-arg;return true;}
public:ReplacementFor_uint ReplacementFor_base;InputDevice(InputDevice const&)=
delete;InputDevice&operator=(InputDevice const&)=delete;static inline bool 
ReplacementFor_isSpace(char ReplacementFor_c){return static_cast<unsigned char>(
ReplacementFor_c-'\t')<(0x113d+2539-0x1b23)||ReplacementFor_c==
((char)(0x81+8640-0x2221));}static inline bool ReplacementFor_isDigit(char 
ReplacementFor_c){return static_cast<unsigned char>(ReplacementFor_c-
((char)(0x2195+304-0x2295)))<(0x1214+4937-0x2553);}static inline bool 
ReplacementFor_isUpper(char ReplacementFor_c){return static_cast<unsigned char>(
ReplacementFor_c-((char)(0x1f42+184-0x1fb9)))<(0x16f6+1896-0x1e44);}static 
inline bool ReplacementFor_isLower(char ReplacementFor_c){return static_cast<
unsigned char>(ReplacementFor_c-((char)(0x229c+674-0x24dd)))<(0x1b60+216-0x1c1e)
;}static inline bool ReplacementFor_isOneOf(char ReplacementFor_c,const char*str
){return strchr(str,ReplacementFor_c)!=nullptr;}void ReplacementFor_putBack(){--
ReplacementFor_head;}inline bool ReplacementFor_readChar(char&arg){if(
__builtin_expect(ReplacementFor_head>=ReplacementFor_tail,false)){
ReplacementFor_fillInput();if(__builtin_expect(ReplacementFor_head>=
ReplacementFor_tail,false))return arg='\0',false;}return arg=*
ReplacementFor_head++,true;}template<class ReplacementFor_UnaryPredicate>inline 
char ReplacementFor_skipCharacters(ReplacementFor_UnaryPredicate 
ReplacementFor_isSkipped){char ReplacementFor_c;do{ReplacementFor_c=nextChar();}
while(ReplacementFor_isSkipped(ReplacementFor_c));return ReplacementFor_c;}
inline char ReplacementFor_skipCharacters(){return ReplacementFor_skipCharacters
(ReplacementFor_isSpace);}template<class ReplacementFor_UnaryPredicate>inline 
int ReplacementFor_readString(char*arg,int ReplacementFor_limit,
ReplacementFor_UnaryPredicate ReplacementFor_isTerminator,bool 
ReplacementFor_skip){int ReplacementFor_charsRead=(0x109a+2418-0x1a0c);if(
ReplacementFor_skip)ReplacementFor_skipCharacters(ReplacementFor_isTerminator),
--ReplacementFor_head;for(--ReplacementFor_limit;ReplacementFor_head<
ReplacementFor_tail;ReplacementFor_fillInput()){ReplacementFor_ptrdiff_t 
chunkSize=ReplacementFor_find_if(ReplacementFor_head,min(ReplacementFor_tail,
ReplacementFor_head+ReplacementFor_limit-ReplacementFor_charsRead),
ReplacementFor_isTerminator)-ReplacementFor_head;arg=copy_n(ReplacementFor_head,
chunkSize,arg);ReplacementFor_head+=chunkSize;ReplacementFor_charsRead+=
chunkSize;if(chunkSize==(0xb00+3643-0x193b)||ReplacementFor_head<
ReplacementFor_tail)break;}return*arg='\0',ReplacementFor_charsRead;}inline int 
ReplacementFor_readString(char*arg,int ReplacementFor_limit,const char*
ReplacementFor_terminators,bool ReplacementFor_skip){if(!*
ReplacementFor_terminators)return ReplacementFor_readString(arg,
ReplacementFor_limit,InputDevice::ReplacementFor_isSpace,ReplacementFor_skip);
return ReplacementFor_readString(arg,ReplacementFor_limit,[
ReplacementFor_terminators](char ReplacementFor_c){return InputDevice::
ReplacementFor_isOneOf(ReplacementFor_c,ReplacementFor_terminators);},
ReplacementFor_skip);}inline bool read(ReplacementFor_Detail::
ReplacementFor_Base ReplacementFor_newBase){ReplacementFor_base=
ReplacementFor_newBase.value;return true;}inline bool read(){return true;}inline
 bool read(char&arg){return ReplacementFor_readChar(arg);}template<class 
ReplacementFor_I>inline typename enable_if<is_integral<ReplacementFor_I>::value
&&ReplacementFor_is_unsigned<ReplacementFor_I>::value,bool>::type read(
ReplacementFor_I&arg){return ReplacementFor_readUnsignedInt(arg,
ReplacementFor_skipCharacters())>(0x5b9+4655-0x17e8);}template<class 
ReplacementFor_I>inline typename enable_if<is_integral<ReplacementFor_I>::value
&&ReplacementFor_is_signed<ReplacementFor_I>::value,bool>::type read(
ReplacementFor_I&arg){return ReplacementFor_readSignedInt(arg,
ReplacementFor_skipCharacters());}template<class F>inline typename enable_if<
is_floating_point<F>::value,bool>::type read(F&arg){return 
ReplacementFor_readFloatingPoint(arg,ReplacementFor_skipCharacters());}inline 
bool read(const char&arg){ReplacementFor_skipCharacters([arg](char 
ReplacementFor_c){return arg!=ReplacementFor_c;});return true;}inline bool read(
const char*arg){if(*arg)ReplacementFor_skipCharacters([arg](char 
ReplacementFor_c){return InputDevice::ReplacementFor_isOneOf(ReplacementFor_c,
arg);});else ReplacementFor_skipCharacters();return ReplacementFor_putBack(),
true;}inline bool read(bool(*ReplacementFor_isSkipped)(char)){
ReplacementFor_skipCharacters(ReplacementFor_isSkipped);ReplacementFor_putBack()
;return true;}template<class ReplacementFor_I,class ReplacementFor_Terminator,
class...ReplacementFor_Ts>inline typename enable_if<is_integral<ReplacementFor_I
>::value,bool>::type read(char*arg,ReplacementFor_I ReplacementFor_limit,
ReplacementFor_Terminator ReplacementFor_terminator,ReplacementFor_Ts&&...
ReplacementFor_args){ReplacementFor_readString(arg,static_cast<int>(
ReplacementFor_limit),ReplacementFor_terminator,true);return read(forward<
ReplacementFor_Ts>(ReplacementFor_args)...);}template<class ReplacementFor_I>
inline typename enable_if<is_integral<ReplacementFor_I>::value,bool>::type read(
char*arg,ReplacementFor_I ReplacementFor_limit){return read(arg,
ReplacementFor_limit,"");}template<class...ReplacementFor_Ts>inline bool read(
char*first,char*last,ReplacementFor_Ts&&...ReplacementFor_args){return read(
first,static_cast<int>(last-first),forward<ReplacementFor_Ts>(
ReplacementFor_args)...);}template<int ReplacementFor_N,class...
ReplacementFor_Ts>inline bool read(char(&arg)[ReplacementFor_N],
ReplacementFor_Ts&&...ReplacementFor_args){return read(static_cast<char*>(arg),
ReplacementFor_N,forward<ReplacementFor_Ts>(ReplacementFor_args)...);}template<
class ReplacementFor_Terminator,class...ReplacementFor_Ts>inline bool read(
string&arg,ReplacementFor_Terminator ReplacementFor_terminator,ReplacementFor_Ts
&&...ReplacementFor_args){for(int length=max((0x1869+1752-0x1f31),static_cast<
int>(arg.capacity())),last=(0x1ae0+1702-0x2186);;length=last+=length){arg.resize
(last+length);int ReplacementFor_charsRead=ReplacementFor_readString(&arg[last],
length+(0x22f+8026-0x2188),ReplacementFor_terminator,last==(0xaa1+2532-0x1485));
if(ReplacementFor_charsRead<length){arg.resize(last+ReplacementFor_charsRead);
return read(forward<ReplacementFor_Ts>(ReplacementFor_args)...);}}}inline bool 
read(string&arg){return read(arg,"");}template<class ReplacementFor_T1,class 
ReplacementFor_T2>inline bool read(pair<ReplacementFor_T1,ReplacementFor_T2>&arg
){return read(arg.first,arg.second);}template<class ReplacementFor_T>inline bool
 read(ReplacementFor_complex<ReplacementFor_T>&arg){ReplacementFor_T 
ReplacementFor_real,ReplacementFor_imag;if(!read(ReplacementFor_real,
ReplacementFor_imag))return false;arg.ReplacementFor_real(ReplacementFor_real),
arg.ReplacementFor_imag(ReplacementFor_imag);return true;}template<class 
ReplacementFor_T>inline bool read(vector<ReplacementFor_T>&arg){
ReplacementFor_uint ReplacementFor_n;if(!read(ReplacementFor_n))return false;arg
.resize(ReplacementFor_n);return read(arg.begin(),arg.end());}template<class 
ReplacementFor_Iterator,class...ReplacementFor_Ts>inline typename enable_if<
ReplacementFor_is_iterator<ReplacementFor_Iterator>::value,bool>::type read(
ReplacementFor_Iterator first,ReplacementFor_Iterator last,ReplacementFor_Ts&&
...ReplacementFor_args){for(;first!=last;++first)if(!read(*first))return false;
return read(forward<ReplacementFor_Ts>(ReplacementFor_args)...);}template<class 
ReplacementFor_Iterator,class ReplacementFor_I,class...ReplacementFor_Ts>inline 
typename enable_if<ReplacementFor_is_iterator<ReplacementFor_Iterator>::value&&
is_integral<ReplacementFor_I>::value,bool>::type read(ReplacementFor_Iterator 
first,ReplacementFor_I ReplacementFor_count,ReplacementFor_Ts&&...
ReplacementFor_args){return read(first,first+ReplacementFor_count,forward<
ReplacementFor_Ts>(ReplacementFor_args)...);}template<class ReplacementFor_T>
inline auto read(ReplacementFor_T&arg)->decltype(arg.read(*this)){return arg.
read(*this);}template<class ReplacementFor_T0,class ReplacementFor_T1,class...
ReplacementFor_Ts>inline typename enable_if<!ReplacementFor_is_iterator<
ReplacementFor_T0>::value&&!is_convertible<ReplacementFor_T0,char*>::value,bool>
::type read(ReplacementFor_T0&&ReplacementFor_arg0,ReplacementFor_T1&&
ReplacementFor_arg1,ReplacementFor_Ts&&...ReplacementFor_args){return read(
forward<ReplacementFor_T0>(ReplacementFor_arg0))&&read(forward<ReplacementFor_T1
>(ReplacementFor_arg1),forward<ReplacementFor_Ts>(ReplacementFor_args)...);}};
class ReplacementFor_InputFile:public InputDevice{FILE*file;bool 
ReplacementFor_lineBuffered;bool ReplacementFor_owner;char ReplacementFor_buffer
[ReplacementFor_BUFFER_SIZE];void ReplacementFor_fillInput()override{
ReplacementFor_head=ReplacementFor_buffer;*ReplacementFor_buffer='\0';if(
__builtin_expect(!ReplacementFor_lineBuffered,true)){ReplacementFor_tail=
ReplacementFor_head+fread(ReplacementFor_buffer,(0x1+5386-0x150a),
ReplacementFor_BUFFER_SIZE,file);}else{ReplacementFor_tail=ReplacementFor_head;
if(fgets(ReplacementFor_buffer,ReplacementFor_BUFFER_SIZE,file))while(*
ReplacementFor_tail)++ReplacementFor_tail;}}public:ReplacementFor_InputFile(FILE
*file=stdin,bool ReplacementFor_lineBuffered=true,bool 
ReplacementFor_takeOwnership=false):InputDevice(ReplacementFor_buffer,
ReplacementFor_buffer),file(file),ReplacementFor_lineBuffered(
ReplacementFor_lineBuffered),ReplacementFor_owner(ReplacementFor_takeOwnership){
}ReplacementFor_InputFile(const char*ReplacementFor_fileName):
ReplacementFor_InputFile(fopen(ReplacementFor_fileName,"\x72"),false,true){}~
ReplacementFor_InputFile(){if(ReplacementFor_owner)fclose(file);}};class 
ReplacementFor_InputString:public InputDevice{void ReplacementFor_fillInput()
override{while(*ReplacementFor_tail)++ReplacementFor_tail;}public:
ReplacementFor_InputString(const string&s):InputDevice(s.ReplacementFor_data(),s
.ReplacementFor_data()+s.size()){}ReplacementFor_InputString(const char*s):
InputDevice(s,s+strlen(s)){}};class ReplacementFor_OutputDevice{protected:char 
ReplacementFor_buffer[ReplacementFor_BUFFER_SIZE+ReplacementFor_MAX_LENGTH];char
*output;char*end;bool ReplacementFor_separate;ReplacementFor_OutputDevice():
output(ReplacementFor_buffer),end(ReplacementFor_buffer+
ReplacementFor_BUFFER_SIZE+ReplacementFor_MAX_LENGTH),ReplacementFor_separate(
false),ReplacementFor_width(ReplacementFor_setWidth().value),fill(
ReplacementFor_setFill().value),ReplacementFor_base(ReplacementFor_setBase().
value),precision(setPrecision().value),delimiter(ReplacementFor_setDelimiter().
value){ReplacementFor_computeBasePower();}virtual void 
ReplacementFor_writeToDevice(ReplacementFor_uint ReplacementFor_count)=0;inline 
void ReplacementFor_flushMaybe(){if(__builtin_expect(output>=
ReplacementFor_buffer+ReplacementFor_BUFFER_SIZE,false)){
ReplacementFor_writeToDevice(ReplacementFor_BUFFER_SIZE);output=copy(
ReplacementFor_buffer+ReplacementFor_BUFFER_SIZE,output,ReplacementFor_buffer);}
}void ReplacementFor_computeBasePower(){ReplacementFor_basePower=
(0xff+6208-0x193e);for(ReplacementFor_uint ReplacementFor_i=(0x885+401-0xa16);
ReplacementFor_i<precision;++ReplacementFor_i)ReplacementFor_basePower*=
ReplacementFor_base;}template<class ReplacementFor_I>inline char*
ReplacementFor_writeUnsignedInt(ReplacementFor_I arg,char*last){if(
__builtin_expect(arg==(0xce9+1528-0x12e1),false))*--last=
((char)(0x38d+4928-0x169d));if(__builtin_expect(ReplacementFor_base==
(0x425+3009-0xfdc),true)){for(;arg;arg/=(0x111+6670-0x1b15))*--last=
((char)(0xa2d+725-0xcd2))+arg%(0x1abf+795-0x1dd0);}else for(;arg;arg/=
ReplacementFor_base){ReplacementFor_I ReplacementFor_digit=arg%
ReplacementFor_base;*--last=ReplacementFor_digit<(0xe10+128-0xe86)?
((char)(0x13ed+573-0x15fa))+ReplacementFor_digit:((char)(0xf28+3367-0x1c0e))-
(0x143f+834-0x1777)+ReplacementFor_digit;}return last;}template<class 
ReplacementFor_I>inline char*ReplacementFor_writeSignedInt(ReplacementFor_I arg,
char*last){auto unsignedArg=static_cast<typename make_unsigned<ReplacementFor_I>
::type>(arg);if(arg<(0x12b4+2747-0x1d6f)){last=ReplacementFor_writeUnsignedInt(~
unsignedArg+(0x18a+3487-0xf28),last);*--last=((char)(0xdc0+544-0xfb3));return 
last;}return ReplacementFor_writeUnsignedInt(unsignedArg,last);}template<class F
>char*ReplacementFor_writeFloatingPoint(F arg,char*last){bool 
ReplacementFor_negative=ReplacementFor_signbit(arg);if(ReplacementFor_negative)
arg=-arg;if(ReplacementFor_isnan(arg))for(int ReplacementFor_i=
(0x778+2344-0x10a0);ReplacementFor_i<(0xe48+3998-0x1de3);++ReplacementFor_i)*--
last=ReplacementFor_i["\x4e\x61\x4e"];else if(ReplacementFor_isinf(arg))for(int 
ReplacementFor_i=(0xed6+5648-0x24e6);ReplacementFor_i<(0x11bc+5082-0x2593);++
ReplacementFor_i)*--last=ReplacementFor_i["\x66\x6e\x49"];else{auto 
ReplacementFor_integerPart=static_cast<unsigned long long>(arg);auto 
ReplacementFor_fractionalPart=static_cast<unsigned long long>((arg-
ReplacementFor_integerPart)*ReplacementFor_basePower+F(0.5));if(
ReplacementFor_fractionalPart>=ReplacementFor_basePower)++
ReplacementFor_integerPart,ReplacementFor_fractionalPart=(0x86d+1796-0xf71);char
*ReplacementFor_point=last-precision;if(precision>(0x7d1+3155-0x1424)){::fill(
ReplacementFor_point,ReplacementFor_writeUnsignedInt(
ReplacementFor_fractionalPart,last),((char)(0x3cc+3338-0x10a6)));*--
ReplacementFor_point=((char)(0x80c+5735-0x1e45));}last=
ReplacementFor_writeUnsignedInt(ReplacementFor_integerPart,ReplacementFor_point)
;}if(ReplacementFor_negative)*--last=((char)(0x103c+1452-0x15bb));return last;}
inline int ReplacementFor_writeT(char*first){int ReplacementFor_delimiterLength=
ReplacementFor_separate?ReplacementFor_writeDelimiter():(0x202a+1459-0x25dd);
ReplacementFor_separate=true;ReplacementFor_uint ReplacementFor_charsWritten=
static_cast<ReplacementFor_uint>(end-first);if(__builtin_expect(
ReplacementFor_charsWritten<ReplacementFor_width,false))
ReplacementFor_charsWritten+=writeFill(ReplacementFor_width-
ReplacementFor_charsWritten);output=copy(first,end,output);
ReplacementFor_flushMaybe();return ReplacementFor_delimiterLength+static_cast<
int>(ReplacementFor_charsWritten);}inline int writeFill(ReplacementFor_uint 
ReplacementFor_count){int ReplacementFor_charsWritten=static_cast<int>(
ReplacementFor_count);if(__builtin_expect(output+ReplacementFor_count+
ReplacementFor_MAX_LENGTH<end,true)){if(ReplacementFor_count==(0x67+5684-0x169a)
)*output++=fill;else output=ReplacementFor_fill_n(output,ReplacementFor_count,
fill);}else for(ReplacementFor_uint chunkSize=static_cast<ReplacementFor_uint>(
ReplacementFor_buffer+ReplacementFor_BUFFER_SIZE-output);;chunkSize=
ReplacementFor_BUFFER_SIZE){if(chunkSize>ReplacementFor_count)chunkSize=
ReplacementFor_count;output=ReplacementFor_fill_n(output,chunkSize,fill);
ReplacementFor_flushMaybe();if((ReplacementFor_count-=chunkSize)==
(0x1530+2137-0x1d89))break;}return ReplacementFor_charsWritten;}public:
ReplacementFor_uint ReplacementFor_width;char fill;ReplacementFor_uint 
ReplacementFor_base;ReplacementFor_uint precision;unsigned long long 
ReplacementFor_basePower;string delimiter;ReplacementFor_OutputDevice(
ReplacementFor_OutputDevice const&)=delete;ReplacementFor_OutputDevice&operator=
(ReplacementFor_OutputDevice const&)=delete;virtual~ReplacementFor_OutputDevice(
){};inline int ReplacementFor_writeChar(char arg){ReplacementFor_separate=false;
*output++=arg;ReplacementFor_flushMaybe();return(0x712+4463-0x1880);}inline int 
ReplacementFor_writeString(const char*arg,size_t length,bool 
ReplacementFor_checkWidth=true){ReplacementFor_separate=false;
ReplacementFor_uint ReplacementFor_count=static_cast<ReplacementFor_uint>(length
);int ReplacementFor_charsWritten=static_cast<int>(ReplacementFor_count)+(
ReplacementFor_checkWidth&&ReplacementFor_count<ReplacementFor_width?writeFill(
ReplacementFor_width-ReplacementFor_count):(0xb03+1807-0x1212));if(
__builtin_expect(output+ReplacementFor_count+ReplacementFor_MAX_LENGTH<end,true)
){if(ReplacementFor_count==(0xb39+1200-0xfe8))*output++=*arg;else output=copy_n(
arg,ReplacementFor_count,output);}else for(ReplacementFor_uint chunkSize=
static_cast<ReplacementFor_uint>(ReplacementFor_buffer+
ReplacementFor_BUFFER_SIZE-output);;chunkSize=ReplacementFor_BUFFER_SIZE){if(
chunkSize>ReplacementFor_count)chunkSize=ReplacementFor_count;output=copy_n(arg,
chunkSize,output);ReplacementFor_flushMaybe();if((ReplacementFor_count-=
chunkSize)==(0x1f1b+411-0x20b6))break;arg+=chunkSize;}return 
ReplacementFor_charsWritten;}inline int ReplacementFor_writeDelimiter(){return 
ReplacementFor_writeString(delimiter.c_str(),delimiter.size(),false);}inline 
void ReplacementFor_flush(){ReplacementFor_writeToDevice(static_cast<
ReplacementFor_uint>(output-ReplacementFor_buffer));output=ReplacementFor_buffer
;}inline int write(ReplacementFor_Detail::ReplacementFor_Width 
ReplacementFor_newWidth){ReplacementFor_width=ReplacementFor_newWidth.value;
return(0x4c6+3340-0x11d2);}inline int write(ReplacementFor_Detail::Fill 
ReplacementFor_newFill){fill=ReplacementFor_newFill.value;return
(0x12a7+1325-0x17d4);}inline int write(ReplacementFor_Detail::
ReplacementFor_Base ReplacementFor_newBase){ReplacementFor_base=
ReplacementFor_newBase.value;ReplacementFor_computeBasePower();return
(0xe36+5677-0x2463);}inline int write(ReplacementFor_Detail::Precision 
ReplacementFor_newPrecision){precision=ReplacementFor_newPrecision.value;
ReplacementFor_computeBasePower();return(0x534+2611-0xf67);}inline int write(
ReplacementFor_Detail::Delimiter ReplacementFor_newDelimiter){delimiter=
ReplacementFor_newDelimiter.value;return(0x19dd+1303-0x1ef4);}inline int write()
{return(0xd65+74-0xdaf);}inline int write(char arg){return 
ReplacementFor_writeChar(arg);}template<class ReplacementFor_I>inline typename 
enable_if<is_integral<ReplacementFor_I>::value&&ReplacementFor_is_unsigned<
ReplacementFor_I>::value,int>::type write(ReplacementFor_I arg){return 
ReplacementFor_writeT(ReplacementFor_writeUnsignedInt(arg,end));}template<class 
ReplacementFor_I>inline typename enable_if<is_integral<ReplacementFor_I>::value
&&ReplacementFor_is_signed<ReplacementFor_I>::value,int>::type write(
ReplacementFor_I arg){return ReplacementFor_writeT(ReplacementFor_writeSignedInt
(arg,end));}template<class F>inline typename enable_if<is_floating_point<F>::
value,int>::type write(F arg){return ReplacementFor_writeT(
ReplacementFor_writeFloatingPoint(arg,end));}inline int write(const char*arg){
return ReplacementFor_writeString(arg,strlen(arg));}template<int 
ReplacementFor_N>inline int write(char(&arg)[ReplacementFor_N]){return 
ReplacementFor_writeString(arg,strlen(arg));}inline int write(const string&arg){
return ReplacementFor_writeString(arg.c_str(),arg.size());}template<class 
ReplacementFor_T1,class ReplacementFor_T2>inline int write(const pair<
ReplacementFor_T1,ReplacementFor_T2>&arg){int ReplacementFor_charsWritten=write(
arg.first);ReplacementFor_charsWritten+=ReplacementFor_writeDelimiter();return 
ReplacementFor_charsWritten+write(arg.second);}template<class ReplacementFor_T>
inline int write(const ReplacementFor_complex<ReplacementFor_T>&arg){return 
write(ReplacementFor_real(arg),ReplacementFor_imag(arg));}template<class 
ReplacementFor_Iterator,class...ReplacementFor_Ts>inline typename enable_if<
ReplacementFor_is_iterator<ReplacementFor_Iterator>::value,int>::type write(
ReplacementFor_Iterator first,ReplacementFor_Iterator last,ReplacementFor_Ts&&
...ReplacementFor_args){int ReplacementFor_charsWritten=(0x586+3839-0x1485);for(
;first!=last;ReplacementFor_charsWritten+=++first==last?(0x10ff+1760-0x17df):
ReplacementFor_writeDelimiter())ReplacementFor_charsWritten+=write(*first);
return ReplacementFor_charsWritten+write(forward<ReplacementFor_Ts>(
ReplacementFor_args)...);}template<class ReplacementFor_Iterator,class 
ReplacementFor_I,class...ReplacementFor_Ts>inline typename enable_if<
ReplacementFor_is_iterator<ReplacementFor_Iterator>::value&&is_integral<
ReplacementFor_I>::value,int>::type write(ReplacementFor_Iterator first,
ReplacementFor_I ReplacementFor_count,ReplacementFor_Ts&&...ReplacementFor_args)
{return write(first,first+ReplacementFor_count,forward<ReplacementFor_Ts>(
ReplacementFor_args)...);}template<class ReplacementFor_T>inline auto write(
const ReplacementFor_T&arg)->decltype(arg.write(*this)){return arg.write(*this);
}template<class ReplacementFor_T0,class ReplacementFor_T1,class...
ReplacementFor_Ts>inline typename enable_if<!ReplacementFor_is_iterator<
ReplacementFor_T0>::value,int>::type write(ReplacementFor_T0&&
ReplacementFor_arg0,ReplacementFor_T1&&ReplacementFor_arg1,ReplacementFor_Ts&&
...ReplacementFor_args){int ReplacementFor_charsWritten=write(forward<
ReplacementFor_T0>(ReplacementFor_arg0));return ReplacementFor_charsWritten+
write(forward<ReplacementFor_T1>(ReplacementFor_arg1),forward<ReplacementFor_Ts>
(ReplacementFor_args)...);}};class ReplacementFor_OutputFile:public 
ReplacementFor_OutputDevice{FILE*file;bool ReplacementFor_owner;void 
ReplacementFor_writeToDevice(ReplacementFor_uint ReplacementFor_count)override{
fwrite(ReplacementFor_buffer,(0x157b+3563-0x2365),ReplacementFor_count,file);
fflush(file);}public:ReplacementFor_OutputFile(FILE*file=stdout,bool 
ReplacementFor_takeOwnership=false):file(file),ReplacementFor_owner(
ReplacementFor_takeOwnership){}ReplacementFor_OutputFile(const char*
ReplacementFor_fileName):ReplacementFor_OutputFile(fopen(ReplacementFor_fileName
,"\x77"),true){}~ReplacementFor_OutputFile()override{ReplacementFor_flush();if(
ReplacementFor_owner)fclose(file);}};class ReplacementFor_OutputString:public 
ReplacementFor_OutputDevice{string&str;void ReplacementFor_writeToDevice(
ReplacementFor_uint ReplacementFor_count)override{str.ReplacementFor_append(
ReplacementFor_buffer,ReplacementFor_count);}public:ReplacementFor_OutputString(
string&str):ReplacementFor_OutputDevice(),str(str){}~ReplacementFor_OutputString
()override{ReplacementFor_flush();}};ReplacementFor_unique_ptr<
ReplacementFor_InputFile>input;ReplacementFor_unique_ptr<
ReplacementFor_OutputFile>output;ReplacementFor_unique_ptr<
ReplacementFor_OutputFile>logs;template<class...ReplacementFor_Ts>inline void 
read(ReplacementFor_Ts&&...ReplacementFor_args){assert(input->read(forward<
ReplacementFor_Ts>(ReplacementFor_args)...));}template<class...ReplacementFor_Ts
>inline void ReplacementFor_writeln(ReplacementFor_Ts&&...ReplacementFor_args){
logs->write(forward<ReplacementFor_Ts>(ReplacementFor_args)...,'\n');logs->
ReplacementFor_flush();}class TestCase{public:static const int ReplacementFor_N=
(0x4d5+1276-0x57a);int ReplacementFor_d,ReplacementFor_n,ReplacementFor_k[
ReplacementFor_N],s[ReplacementFor_N];void input(){read(ReplacementFor_d,
ReplacementFor_n);ReplacementFor_REP(ReplacementFor_i,ReplacementFor_n)read(
ReplacementFor_k[ReplacementFor_i],s[ReplacementFor_i]);}void generate(bool 
ReplacementFor_big,int ReplacementFor_seed){auto rnd=bind(
ReplacementFor_uniform_int_distribution<int>((0x346+4479-0x14c5),
(0xf90+3305-0x1c70)),ReplacementFor_default_random_engine(ReplacementFor_seed));
}void solveSlow(){output->ReplacementFor_flush();}void solve(){double last=
(0x567+1398-0xadd);ReplacementFor_REP(ReplacementFor_i,ReplacementFor_n)
ReplacementFor_smax(last,double(ReplacementFor_d-ReplacementFor_k[
ReplacementFor_i])/s[ReplacementFor_i]);write(ReplacementFor_d/last);output->
ReplacementFor_flush();}string outputStr;TestCase():output(new 
ReplacementFor_OutputString(outputStr)){};private:ReplacementFor_unique_ptr<
ReplacementFor_OutputDevice>output;template<class...ReplacementFor_Ts>inline int
 write(ReplacementFor_Ts&&...ReplacementFor_args){return output->write(forward<
ReplacementFor_Ts>(ReplacementFor_args)...);}template<class...ReplacementFor_Ts>
inline int ReplacementFor_writeln(ReplacementFor_Ts&&...ReplacementFor_args){
return write(forward<ReplacementFor_Ts>(ReplacementFor_args)...,'\n');}};mutex 
inputMutex;int ReplacementFor_testIndex,ReplacementFor_testCount;vector<string>
answer;void ReplacementFor_work(){while(true){inputMutex.ReplacementFor_lock();
if(ReplacementFor_testIndex>=ReplacementFor_testCount){inputMutex.unlock();break
;}int ReplacementFor_current=ReplacementFor_testIndex++;ReplacementFor_writeln(
"\x43\x61\x73\x65\x20",ReplacementFor_current+(0x1541+4204-0x25ac),
"\x20\x73\x74\x61\x72\x74\x65\x64");ReplacementFor_unique_ptr<TestCase>test(new 
TestCase());test->input();inputMutex.unlock();test->solve();answer[
ReplacementFor_current].swap(test->outputStr);}}void ReplacementFor_writeAnswer(
int test,const string&answer){output->write("\x43\x61\x73\x65\x20\x23",test+
(0xba5+1909-0x1319),"\x3a\x20",answer,"\n");output->ReplacementFor_flush();}void
 ReplacementFor_randomTest(){for(int ReplacementFor_i=(0x3d5+7640-0x21ad);
ReplacementFor_i<(0x1763+165-0x17a4);++ReplacementFor_i){
ReplacementFor_unique_ptr<TestCase>test(new TestCase());test->generate(false,
ReplacementFor_i);test->solve();string output;output.swap(test->outputStr);test
->solveSlow();if(test->outputStr!=output){ReplacementFor_writeln(
"\x45\x72\x72\x6f\x72\x20\x6f\x6e\x20\x74\x65\x73\x74\x20\x23",ReplacementFor_i+
(0xbaf+4893-0x1ecb));ReplacementFor_writeln(
"\x45\x78\x70\x65\x63\x74\x65\x64\x3a" "\n",test->outputStr);
ReplacementFor_writeln("\x52\x65\x63\x65\x69\x76\x65\x64\x3a" "\n",output);}}
ReplacementFor_writeln("\n\n" "\x54\x65\x73\x74\x20\x74\x69\x6d\x65\x3a\x20",
static_cast<double>(clock())/CLOCKS_PER_SEC);exit((0xce1+1813-0x13f6));}void 
ReplacementFor_maxTest(){for(int ReplacementFor_i=(0x1d7d+590-0x1fcb);
ReplacementFor_i<(0x1a61+1535-0x1ffc);++ReplacementFor_i){
ReplacementFor_unique_ptr<TestCase>test(new TestCase());test->generate(true,
ReplacementFor_i);test->solve();ReplacementFor_writeAnswer(ReplacementFor_i,test
->outputStr);}ReplacementFor_writeln(
"\n\n" "\x54\x65\x73\x74\x20\x74\x69\x6d\x65\x3a\x20",static_cast<double>(clock(
))/CLOCKS_PER_SEC);exit((0x542+4457-0x16ab));}int main(){input.
ReplacementFor_reset(new ReplacementFor_InputFile(
"\x41\x2d\x73\x6d\x61\x6c\x6c\x2d\x61\x74\x74\x65\x6d\x70\x74\x30\x2e\x69\x6e"))
;output.ReplacementFor_reset(new ReplacementFor_OutputFile(
"\x6f\x75\x74\x70\x75\x74\x2e\x74\x78\x74"));logs.ReplacementFor_reset(new 
ReplacementFor_OutputFile(stderr));logs->write(setPrecision((0x42d+397-0x5b6)));
ReplacementFor_testIndex=(0x14f+5917-0x186c);input->read(
ReplacementFor_testCount);answer.resize(ReplacementFor_testCount);
#ifndef ReplacementFor_SINGLE_THREAD
vector<thread>threads;for(int ReplacementFor_i=(0x927+2764-0x13f3);
ReplacementFor_i<thread::hardware_concurrency();++ReplacementFor_i)threads.
emplace_back(ReplacementFor_work);for(auto&thread:threads)thread.join();for(int 
ReplacementFor_i=(0x1332+1778-0x1a24);ReplacementFor_i<ReplacementFor_testCount;
++ReplacementFor_i)ReplacementFor_writeAnswer(ReplacementFor_i,answer[
ReplacementFor_i]);
#else
for(int ReplacementFor_i=(0xc09+2481-0x15ba);ReplacementFor_i<
ReplacementFor_testCount;++ReplacementFor_i){ReplacementFor_writeln(
"\x43\x61\x73\x65\x20",ReplacementFor_i+(0x217+486-0x3fc),
"\x20\x73\x74\x61\x72\x74\x65\x64");ReplacementFor_unique_ptr<TestCase>test(new 
TestCase());test->input();test->solve();ReplacementFor_writeAnswer(
ReplacementFor_i,test->outputStr);}
#endif
ReplacementFor_writeln("\n\n" "\x54\x6f\x74\x61\x6c\x20\x74\x69\x6d\x65\x3a\x20"
,static_cast<double>(clock())/CLOCKS_PER_SEC);return(0x20f+8709-0x2414);}
