
#define ASSERT(...) assert(ReplacementFor___VA_ARGS__)
#include <stdexcept>
#include <iostream>
#include <iomanip>
#include <sstream>
#include <fstream>
#include <cassert>
#include <cstring>
#include <cstdarg>
#include <cstdio>
#include <memory>
#include <random>
#include <cmath>
#include <ctime>
#include <unordered_map>
#include <unordered_set>
#include <functional>
#include <algorithm>
#include <complex>
#include <numeric>
#include <limits>
#include <bitset>
#include <vector>
#include <string>
#include <queue>
#include <deque>
#include <array>
#include <list>
#include <map>
#include <set>
#include <thread>
#include <mutex>
using namespace std;
#define ReplacementFor_all(a) (a).begin(), (a).end()
#define ReplacementFor_sz(a) static_cast<int>((a).size())
#define FOR(ReplacementFor_i, a, ReplacementFor_b) for (int ReplacementFor_i(a),\
 ReplacementFor_b_(ReplacementFor_b); ReplacementFor_i < ReplacementFor_b_; ++\
ReplacementFor_i)
#define ReplacementFor_REP(ReplacementFor_i, ReplacementFor_n) FOR (\
ReplacementFor_i, (0x1453+4772-0x26f7), ReplacementFor_n)
#define ReplacementFor_FORD(ReplacementFor_i, a, ReplacementFor_b) for (int \
ReplacementFor_i(a), ReplacementFor_b_(ReplacementFor_b); ReplacementFor_i >= \
ReplacementFor_b_; --ReplacementFor_i)
#define UNIQUE(a) sort(ReplacementFor_all(a)), (a).ReplacementFor_erase(unique(\
ReplacementFor_all(a)), (a).end())
#define ReplacementFor_CL(a, ReplacementFor_v) memset(a, ReplacementFor_v, \
sizeof a)
#define ReplacementFor_eb emplace_back
#define ReplacementFor_pb push_back
#define ReplacementFor_X first
#define ReplacementFor_Y second
typedef long long ReplacementFor_ll;typedef long double ReplacementFor_ld;
typedef vector<int>ReplacementFor_vi;typedef pair<int,int>ReplacementFor_pii;
template<class ReplacementFor_T>using ReplacementFor_min_queue=priority_queue<
ReplacementFor_T,vector<ReplacementFor_T>,greater<ReplacementFor_T>>;const int 
ReplacementFor_INF=static_cast<int>(1e9);const long long ReplacementFor_INF_LL=
static_cast<long long>(4e18);const double ReplacementFor_pi=acos(-1.0);template<
class ReplacementFor_T>ReplacementFor_T&ReplacementFor_smin(ReplacementFor_T&
ReplacementFor_x,const ReplacementFor_T&ReplacementFor_y){if(ReplacementFor_x>
ReplacementFor_y)ReplacementFor_x=ReplacementFor_y;return ReplacementFor_x;}
template<class ReplacementFor_T>ReplacementFor_T&ReplacementFor_smax(
ReplacementFor_T&ReplacementFor_x,const ReplacementFor_T&ReplacementFor_y){if(
ReplacementFor_x<ReplacementFor_y)ReplacementFor_x=ReplacementFor_y;return 
ReplacementFor_x;}template<class ReplacementFor_T>ReplacementFor_T 
ReplacementFor_sqr(const ReplacementFor_T&ReplacementFor_x){return 
ReplacementFor_x*ReplacementFor_x;}template<class ReplacementFor_T>inline int 
ReplacementFor_sgn(const ReplacementFor_T&ReplacementFor_x){return(
ReplacementFor_T((0x48a+3715-0x130d))<ReplacementFor_x)-(ReplacementFor_x<
ReplacementFor_T((0x168+5236-0x15dc)));}template<class ReplacementFor_T>
ReplacementFor_T ReplacementFor_gcd(ReplacementFor_T a,ReplacementFor_T 
ReplacementFor_b){for(a=ReplacementFor_abs(a),ReplacementFor_b=
ReplacementFor_abs(ReplacementFor_b);a&&ReplacementFor_b;a>=ReplacementFor_b?a%=
ReplacementFor_b:ReplacementFor_b%=a);return a+ReplacementFor_b;}template<class 
ReplacementFor_T>struct ReplacementFor_is_commutative{constexpr static bool 
value=true;};template<class ReplacementFor_T>struct ReplacementFor_is_iterator{
template<class ReplacementFor_U,typename enable_if<!is_convertible<
ReplacementFor_U,const char*>::value,int>::type=(0x18a3+2969-0x243c)>constexpr 
static auto ReplacementFor_has_indirection(int)->decltype(*declval<
ReplacementFor_U>(),bool()){return true;}template<class>constexpr static bool 
ReplacementFor_has_indirection(long){return false;}constexpr static bool value=
ReplacementFor_has_indirection<ReplacementFor_T>((0x7ad+810-0xad7));};using 
ReplacementFor_uint=unsigned int;const ReplacementFor_uint 
ReplacementFor_BUFFER_SIZE=(0xb52+1661-0x11ce)<<(0x11f+202-0x1dd);const 
ReplacementFor_uint ReplacementFor_MAX_LENGTH=(0x35d+4744-0x15e4)<<
(0x490+2577-0xe9a);namespace ReplacementFor_Detail{struct ReplacementFor_Width{
ReplacementFor_uint value;};struct Fill{char value;};struct ReplacementFor_Base{
ReplacementFor_uint value;};struct Precision{ReplacementFor_uint value;};struct 
Delimiter{const char*value;};}ReplacementFor_Detail::ReplacementFor_Width 
ReplacementFor_setWidth(ReplacementFor_uint value=(0x47a+496-0x66a)){return{
value};}ReplacementFor_Detail::Fill ReplacementFor_setFill(char value=
((char)(0x1446+3097-0x203f))){return{value};}ReplacementFor_Detail::
ReplacementFor_Base ReplacementFor_setBase(ReplacementFor_uint value=
(0x5ad+744-0x88b)){assert((0xc11+1942-0x13a5)<=value&&value<=(0x5ab+2248-0xe4f))
;return{value};}ReplacementFor_Detail::Precision setPrecision(
ReplacementFor_uint value=(0x8ff+6832-0x23a6)){assert(value<
ReplacementFor_MAX_LENGTH);return{value};}ReplacementFor_Detail::Delimiter 
ReplacementFor_setDelimiter(const char*value="\x20"){return{value};}class 
InputDevice{protected:const char*ReplacementFor_head;const char*
ReplacementFor_tail;InputDevice(const char*ReplacementFor_head,const char*
ReplacementFor_tail):ReplacementFor_head(ReplacementFor_head),
ReplacementFor_tail(ReplacementFor_tail),ReplacementFor_base(
ReplacementFor_setBase().value){}virtual void ReplacementFor_fillInput()=0;
inline char nextChar(){if(__builtin_expect(ReplacementFor_head>=
ReplacementFor_tail,false))ReplacementFor_fillInput();return*ReplacementFor_head
++;}template<class ReplacementFor_I>int ReplacementFor_readUnsignedIntGeneral(
ReplacementFor_I&arg,char ReplacementFor_c){ReplacementFor_I value=
(0xc83+4326-0x1d69);int length=(0xfd4+3539-0x1da7);for(;;++length,
ReplacementFor_c=nextChar()){if(ReplacementFor_isDigit(ReplacementFor_c))
ReplacementFor_c-=((char)(0x4e9+6809-0x1f52));else if(ReplacementFor_isUpper(
ReplacementFor_c))ReplacementFor_c-=((char)(0x5c2+3515-0x133c))-
(0x182b+1-0x1822);else if(ReplacementFor_isLower(ReplacementFor_c))
ReplacementFor_c-=((char)(0x12c8+2053-0x1a6c))-(0x63f+7951-0x2544);else 
ReplacementFor_c=ReplacementFor_base;if(ReplacementFor_c>=ReplacementFor_base)
break;value=ReplacementFor_base*value+ReplacementFor_c;}arg=value;return--
ReplacementFor_head,length;}template<class ReplacementFor_I>inline int 
ReplacementFor_readUnsignedInt(ReplacementFor_I&arg,char ReplacementFor_c){if(
__builtin_expect(ReplacementFor_base>(0x21e3+668-0x2475),false))return 
ReplacementFor_readUnsignedIntGeneral(arg,ReplacementFor_c);ReplacementFor_I 
value=(0x12e0+459-0x14ab);int length=(0x1d8+5994-0x1942);for(;static_cast<
unsigned char>(ReplacementFor_c-((char)(0x138f+2617-0x1d98)))<
ReplacementFor_base;++length,ReplacementFor_c=nextChar())value=
ReplacementFor_base*value+ReplacementFor_c-((char)(0x1709+909-0x1a66));arg=value
;return--ReplacementFor_head,length;}template<class ReplacementFor_I>inline bool
 ReplacementFor_readSignedInt(ReplacementFor_I&arg,char ReplacementFor_c){bool 
ReplacementFor_negative=ReplacementFor_c==((char)(0x19dd+2830-0x24be));if(
ReplacementFor_negative)ReplacementFor_c=nextChar();typename make_unsigned<
ReplacementFor_I>::type unsignedArg;if(ReplacementFor_readUnsignedInt(
unsignedArg,ReplacementFor_c)==(0x1a21+1083-0x1e5c))return false;arg=
ReplacementFor_negative?~static_cast<ReplacementFor_I>(unsignedArg-
(0x1427+3291-0x2101)):static_cast<ReplacementFor_I>(unsignedArg);return true;}
template<class F>bool ReplacementFor_readFloatingPoint(F&arg,char 
ReplacementFor_c){bool ReplacementFor_negative=ReplacementFor_c==
((char)(0x6a9+3403-0x13c7));if(ReplacementFor_negative)ReplacementFor_c=nextChar
();unsigned long long ReplacementFor_integerPart;if(
ReplacementFor_readUnsignedInt(ReplacementFor_integerPart,ReplacementFor_c)==
(0x1f6d+1795-0x2670))return false;arg=static_cast<F>(ReplacementFor_integerPart)
;if(nextChar()==((char)(0x1c24+1015-0x1fed))){unsigned long long 
ReplacementFor_fractionalPart=(0x1b8f+367-0x1cfe);int 
ReplacementFor_fractionalLength=ReplacementFor_readUnsignedInt(
ReplacementFor_fractionalPart,nextChar());if(ReplacementFor_fractionalLength>
(0x96f+97-0x9d0)){unsigned long long ReplacementFor_basePower=
(0x1f04+297-0x202c);for(;ReplacementFor_fractionalLength;--
ReplacementFor_fractionalLength)ReplacementFor_basePower*=ReplacementFor_base;
arg+=static_cast<F>(ReplacementFor_fractionalPart)/ReplacementFor_basePower;}}
else--ReplacementFor_head;if(ReplacementFor_negative)arg=-arg;return true;}
public:ReplacementFor_uint ReplacementFor_base;InputDevice(InputDevice const&)=
delete;InputDevice&operator=(InputDevice const&)=delete;static inline bool 
ReplacementFor_isSpace(char ReplacementFor_c){return static_cast<unsigned char>(
ReplacementFor_c-'\t')<(0x1e1+7354-0x1e96)||ReplacementFor_c==
((char)(0x9c8+3606-0x17be));}static inline bool ReplacementFor_isDigit(char 
ReplacementFor_c){return static_cast<unsigned char>(ReplacementFor_c-
((char)(0xdea+2578-0x17cc)))<(0x1097+3251-0x1d40);}static inline bool 
ReplacementFor_isUpper(char ReplacementFor_c){return static_cast<unsigned char>(
ReplacementFor_c-((char)(0x8e0+5465-0x1df8)))<(0x676+2715-0x10f7);}static inline
 bool ReplacementFor_isLower(char ReplacementFor_c){return static_cast<unsigned 
char>(ReplacementFor_c-((char)(0x1c3+40-0x18a)))<(0x1227+889-0x1586);}static 
inline bool ReplacementFor_isOneOf(char ReplacementFor_c,const char*str){return 
strchr(str,ReplacementFor_c)!=nullptr;}void ReplacementFor_putBack(){--
ReplacementFor_head;}inline bool ReplacementFor_readChar(char&arg){if(
__builtin_expect(ReplacementFor_head>=ReplacementFor_tail,false)){
ReplacementFor_fillInput();if(__builtin_expect(ReplacementFor_head>=
ReplacementFor_tail,false))return arg='\0',false;}return arg=*
ReplacementFor_head++,true;}template<class ReplacementFor_UnaryPredicate>inline 
char ReplacementFor_skipCharacters(ReplacementFor_UnaryPredicate 
ReplacementFor_isSkipped){char ReplacementFor_c;do{ReplacementFor_c=nextChar();}
while(ReplacementFor_isSkipped(ReplacementFor_c));return ReplacementFor_c;}
inline char ReplacementFor_skipCharacters(){return ReplacementFor_skipCharacters
(ReplacementFor_isSpace);}template<class ReplacementFor_UnaryPredicate>inline 
int ReplacementFor_readString(char*arg,int ReplacementFor_limit,
ReplacementFor_UnaryPredicate ReplacementFor_isTerminator,bool 
ReplacementFor_skip){int ReplacementFor_charsRead=(0x1013+3402-0x1d5d);if(
ReplacementFor_skip)ReplacementFor_skipCharacters(ReplacementFor_isTerminator),
--ReplacementFor_head;for(--ReplacementFor_limit;ReplacementFor_head<
ReplacementFor_tail;ReplacementFor_fillInput()){ReplacementFor_ptrdiff_t 
chunkSize=ReplacementFor_find_if(ReplacementFor_head,min(ReplacementFor_tail,
ReplacementFor_head+ReplacementFor_limit-ReplacementFor_charsRead),
ReplacementFor_isTerminator)-ReplacementFor_head;arg=copy_n(ReplacementFor_head,
chunkSize,arg);ReplacementFor_head+=chunkSize;ReplacementFor_charsRead+=
chunkSize;if(chunkSize==(0xa95+1149-0xf12)||ReplacementFor_head<
ReplacementFor_tail)break;}return*arg='\0',ReplacementFor_charsRead;}inline int 
ReplacementFor_readString(char*arg,int ReplacementFor_limit,const char*
ReplacementFor_terminators,bool ReplacementFor_skip){if(!*
ReplacementFor_terminators)return ReplacementFor_readString(arg,
ReplacementFor_limit,InputDevice::ReplacementFor_isSpace,ReplacementFor_skip);
return ReplacementFor_readString(arg,ReplacementFor_limit,[
ReplacementFor_terminators](char ReplacementFor_c){return InputDevice::
ReplacementFor_isOneOf(ReplacementFor_c,ReplacementFor_terminators);},
ReplacementFor_skip);}inline bool read(ReplacementFor_Detail::
ReplacementFor_Base ReplacementFor_newBase){ReplacementFor_base=
ReplacementFor_newBase.value;return true;}inline bool read(){return true;}inline
 bool read(char&arg){return ReplacementFor_readChar(arg);}template<class 
ReplacementFor_I>inline typename enable_if<is_integral<ReplacementFor_I>::value
&&ReplacementFor_is_unsigned<ReplacementFor_I>::value,bool>::type read(
ReplacementFor_I&arg){return ReplacementFor_readUnsignedInt(arg,
ReplacementFor_skipCharacters())>(0x1452+1803-0x1b5d);}template<class 
ReplacementFor_I>inline typename enable_if<is_integral<ReplacementFor_I>::value
&&ReplacementFor_is_signed<ReplacementFor_I>::value,bool>::type read(
ReplacementFor_I&arg){return ReplacementFor_readSignedInt(arg,
ReplacementFor_skipCharacters());}template<class F>inline typename enable_if<
is_floating_point<F>::value,bool>::type read(F&arg){return 
ReplacementFor_readFloatingPoint(arg,ReplacementFor_skipCharacters());}inline 
bool read(const char&arg){ReplacementFor_skipCharacters([arg](char 
ReplacementFor_c){return arg!=ReplacementFor_c;});return true;}inline bool read(
const char*arg){if(*arg)ReplacementFor_skipCharacters([arg](char 
ReplacementFor_c){return InputDevice::ReplacementFor_isOneOf(ReplacementFor_c,
arg);});else ReplacementFor_skipCharacters();return ReplacementFor_putBack(),
true;}inline bool read(bool(*ReplacementFor_isSkipped)(char)){
ReplacementFor_skipCharacters(ReplacementFor_isSkipped);ReplacementFor_putBack()
;return true;}template<class ReplacementFor_I,class ReplacementFor_Terminator,
class...ReplacementFor_Ts>inline typename enable_if<is_integral<ReplacementFor_I
>::value,bool>::type read(char*arg,ReplacementFor_I ReplacementFor_limit,
ReplacementFor_Terminator ReplacementFor_terminator,ReplacementFor_Ts&&...
ReplacementFor_args){ReplacementFor_readString(arg,static_cast<int>(
ReplacementFor_limit),ReplacementFor_terminator,true);return read(forward<
ReplacementFor_Ts>(ReplacementFor_args)...);}template<class ReplacementFor_I>
inline typename enable_if<is_integral<ReplacementFor_I>::value,bool>::type read(
char*arg,ReplacementFor_I ReplacementFor_limit){return read(arg,
ReplacementFor_limit,"");}template<class...ReplacementFor_Ts>inline bool read(
char*first,char*last,ReplacementFor_Ts&&...ReplacementFor_args){return read(
first,static_cast<int>(last-first),forward<ReplacementFor_Ts>(
ReplacementFor_args)...);}template<int ReplacementFor_N,class...
ReplacementFor_Ts>inline bool read(char(&arg)[ReplacementFor_N],
ReplacementFor_Ts&&...ReplacementFor_args){return read(static_cast<char*>(arg),
ReplacementFor_N,forward<ReplacementFor_Ts>(ReplacementFor_args)...);}template<
class ReplacementFor_Terminator,class...ReplacementFor_Ts>inline bool read(
string&arg,ReplacementFor_Terminator ReplacementFor_terminator,ReplacementFor_Ts
&&...ReplacementFor_args){for(int length=max((0x4c0+1258-0x99a),static_cast<int>
(arg.capacity())),last=(0x1c6f+140-0x1cfb);;length=last+=length){arg.resize(last
+length);int ReplacementFor_charsRead=ReplacementFor_readString(&arg[last],
length+(0x10a8+4019-0x205a),ReplacementFor_terminator,last==(0x2ac+266-0x3b6));
if(ReplacementFor_charsRead<length){arg.resize(last+ReplacementFor_charsRead);
return read(forward<ReplacementFor_Ts>(ReplacementFor_args)...);}}}inline bool 
read(string&arg){return read(arg,"");}template<class ReplacementFor_T1,class 
ReplacementFor_T2>inline bool read(pair<ReplacementFor_T1,ReplacementFor_T2>&arg
){return read(arg.first,arg.second);}template<class ReplacementFor_T>inline bool
 read(ReplacementFor_complex<ReplacementFor_T>&arg){ReplacementFor_T 
ReplacementFor_real,ReplacementFor_imag;if(!read(ReplacementFor_real,
ReplacementFor_imag))return false;arg.ReplacementFor_real(ReplacementFor_real),
arg.ReplacementFor_imag(ReplacementFor_imag);return true;}template<class 
ReplacementFor_T>inline bool read(vector<ReplacementFor_T>&arg){
ReplacementFor_uint ReplacementFor_n;if(!read(ReplacementFor_n))return false;arg
.resize(ReplacementFor_n);return read(arg.begin(),arg.end());}template<class 
ReplacementFor_Iterator,class...ReplacementFor_Ts>inline typename enable_if<
ReplacementFor_is_iterator<ReplacementFor_Iterator>::value,bool>::type read(
ReplacementFor_Iterator first,ReplacementFor_Iterator last,ReplacementFor_Ts&&
...ReplacementFor_args){for(;first!=last;++first)if(!read(*first))return false;
return read(forward<ReplacementFor_Ts>(ReplacementFor_args)...);}template<class 
ReplacementFor_Iterator,class ReplacementFor_I,class...ReplacementFor_Ts>inline 
typename enable_if<ReplacementFor_is_iterator<ReplacementFor_Iterator>::value&&
is_integral<ReplacementFor_I>::value,bool>::type read(ReplacementFor_Iterator 
first,ReplacementFor_I ReplacementFor_count,ReplacementFor_Ts&&...
ReplacementFor_args){return read(first,first+ReplacementFor_count,forward<
ReplacementFor_Ts>(ReplacementFor_args)...);}template<class ReplacementFor_T>
inline auto read(ReplacementFor_T&arg)->decltype(arg.read(*this)){return arg.
read(*this);}template<class ReplacementFor_T0,class ReplacementFor_T1,class...
ReplacementFor_Ts>inline typename enable_if<!ReplacementFor_is_iterator<
ReplacementFor_T0>::value&&!is_convertible<ReplacementFor_T0,char*>::value,bool>
::type read(ReplacementFor_T0&&ReplacementFor_arg0,ReplacementFor_T1&&
ReplacementFor_arg1,ReplacementFor_Ts&&...ReplacementFor_args){return read(
forward<ReplacementFor_T0>(ReplacementFor_arg0))&&read(forward<ReplacementFor_T1
>(ReplacementFor_arg1),forward<ReplacementFor_Ts>(ReplacementFor_args)...);}};
class ReplacementFor_InputFile:public InputDevice{FILE*file;bool 
ReplacementFor_lineBuffered;bool ReplacementFor_owner;char ReplacementFor_buffer
[ReplacementFor_BUFFER_SIZE];void ReplacementFor_fillInput()override{
ReplacementFor_head=ReplacementFor_buffer;*ReplacementFor_buffer='\0';if(
__builtin_expect(!ReplacementFor_lineBuffered,true)){ReplacementFor_tail=
ReplacementFor_head+fread(ReplacementFor_buffer,(0x6ff+4056-0x16d6),
ReplacementFor_BUFFER_SIZE,file);}else{ReplacementFor_tail=ReplacementFor_head;
if(fgets(ReplacementFor_buffer,ReplacementFor_BUFFER_SIZE,file))while(*
ReplacementFor_tail)++ReplacementFor_tail;}}public:ReplacementFor_InputFile(FILE
*file=stdin,bool ReplacementFor_lineBuffered=true,bool 
ReplacementFor_takeOwnership=false):InputDevice(ReplacementFor_buffer,
ReplacementFor_buffer),file(file),ReplacementFor_lineBuffered(
ReplacementFor_lineBuffered),ReplacementFor_owner(ReplacementFor_takeOwnership){
}ReplacementFor_InputFile(const char*ReplacementFor_fileName):
ReplacementFor_InputFile(fopen(ReplacementFor_fileName,"\x72"),false,true){}~
ReplacementFor_InputFile(){if(ReplacementFor_owner)fclose(file);}};class 
ReplacementFor_InputString:public InputDevice{void ReplacementFor_fillInput()
override{while(*ReplacementFor_tail)++ReplacementFor_tail;}public:
ReplacementFor_InputString(const string&s):InputDevice(s.ReplacementFor_data(),s
.ReplacementFor_data()+s.size()){}ReplacementFor_InputString(const char*s):
InputDevice(s,s+strlen(s)){}};class ReplacementFor_OutputDevice{protected:char 
ReplacementFor_buffer[ReplacementFor_BUFFER_SIZE+ReplacementFor_MAX_LENGTH];char
*output;char*end;bool ReplacementFor_separate;ReplacementFor_OutputDevice():
output(ReplacementFor_buffer),end(ReplacementFor_buffer+
ReplacementFor_BUFFER_SIZE+ReplacementFor_MAX_LENGTH),ReplacementFor_separate(
false),ReplacementFor_width(ReplacementFor_setWidth().value),fill(
ReplacementFor_setFill().value),ReplacementFor_base(ReplacementFor_setBase().
value),precision(setPrecision().value),delimiter(ReplacementFor_setDelimiter().
value){ReplacementFor_computeBasePower();}virtual void 
ReplacementFor_writeToDevice(ReplacementFor_uint ReplacementFor_count)=0;inline 
void ReplacementFor_flushMaybe(){if(__builtin_expect(output>=
ReplacementFor_buffer+ReplacementFor_BUFFER_SIZE,false)){
ReplacementFor_writeToDevice(ReplacementFor_BUFFER_SIZE);output=copy(
ReplacementFor_buffer+ReplacementFor_BUFFER_SIZE,output,ReplacementFor_buffer);}
}void ReplacementFor_computeBasePower(){ReplacementFor_basePower=
(0x1b51+207-0x1c1f);for(ReplacementFor_uint ReplacementFor_i=
(0x1298+4365-0x23a5);ReplacementFor_i<precision;++ReplacementFor_i)
ReplacementFor_basePower*=ReplacementFor_base;}template<class ReplacementFor_I>
inline char*ReplacementFor_writeUnsignedInt(ReplacementFor_I arg,char*last){if(
__builtin_expect(arg==(0x1b2+8984-0x24ca),false))*--last=
((char)(0x1916+2065-0x20f7));if(__builtin_expect(ReplacementFor_base==
(0x820+3256-0x14ce),true)){for(;arg;arg/=(0x1be7+2573-0x25ea))*--last=
((char)(0x75b+1791-0xe2a))+arg%(0x8fb+4586-0x1adb);}else for(;arg;arg/=
ReplacementFor_base){ReplacementFor_I ReplacementFor_digit=arg%
ReplacementFor_base;*--last=ReplacementFor_digit<(0xf18+3174-0x1b74)?
((char)(0xfda+1303-0x14c1))+ReplacementFor_digit:((char)(0xc4+1220-0x547))-
(0xed5+2703-0x195a)+ReplacementFor_digit;}return last;}template<class 
ReplacementFor_I>inline char*ReplacementFor_writeSignedInt(ReplacementFor_I arg,
char*last){auto unsignedArg=static_cast<typename make_unsigned<ReplacementFor_I>
::type>(arg);if(arg<(0x1f4+5174-0x162a)){last=ReplacementFor_writeUnsignedInt(~
unsignedArg+(0x280+7873-0x2140),last);*--last=((char)(0xdf0+3509-0x1b78));return
 last;}return ReplacementFor_writeUnsignedInt(unsignedArg,last);}template<class 
F>char*ReplacementFor_writeFloatingPoint(F arg,char*last){bool 
ReplacementFor_negative=ReplacementFor_signbit(arg);if(ReplacementFor_negative)
arg=-arg;if(ReplacementFor_isnan(arg))for(int ReplacementFor_i=
(0x8cb+3049-0x14b4);ReplacementFor_i<(0x14a+7208-0x1d6f);++ReplacementFor_i)*--
last=ReplacementFor_i["\x4e\x61\x4e"];else if(ReplacementFor_isinf(arg))for(int 
ReplacementFor_i=(0x58b+3874-0x14ad);ReplacementFor_i<(0x12c6+2078-0x1ae1);++
ReplacementFor_i)*--last=ReplacementFor_i["\x66\x6e\x49"];else{auto 
ReplacementFor_integerPart=static_cast<unsigned long long>(arg);auto 
ReplacementFor_fractionalPart=static_cast<unsigned long long>((arg-
ReplacementFor_integerPart)*ReplacementFor_basePower+F(0.5));if(
ReplacementFor_fractionalPart>=ReplacementFor_basePower)++
ReplacementFor_integerPart,ReplacementFor_fractionalPart=(0xe78+2450-0x180a);
char*ReplacementFor_point=last-precision;if(precision>(0x1bd7+1129-0x2040)){::
fill(ReplacementFor_point,ReplacementFor_writeUnsignedInt(
ReplacementFor_fractionalPart,last),((char)(0x1349+949-0x16ce)));*--
ReplacementFor_point=((char)(0x76b+1111-0xb94));}last=
ReplacementFor_writeUnsignedInt(ReplacementFor_integerPart,ReplacementFor_point)
;}if(ReplacementFor_negative)*--last=((char)(0x11a7+1912-0x18f2));return last;}
inline int ReplacementFor_writeT(char*first){int ReplacementFor_delimiterLength=
ReplacementFor_separate?ReplacementFor_writeDelimiter():(0xfd0+1939-0x1763);
ReplacementFor_separate=true;ReplacementFor_uint ReplacementFor_charsWritten=
static_cast<ReplacementFor_uint>(end-first);if(__builtin_expect(
ReplacementFor_charsWritten<ReplacementFor_width,false))
ReplacementFor_charsWritten+=writeFill(ReplacementFor_width-
ReplacementFor_charsWritten);output=copy(first,end,output);
ReplacementFor_flushMaybe();return ReplacementFor_delimiterLength+static_cast<
int>(ReplacementFor_charsWritten);}inline int writeFill(ReplacementFor_uint 
ReplacementFor_count){int ReplacementFor_charsWritten=static_cast<int>(
ReplacementFor_count);if(__builtin_expect(output+ReplacementFor_count+
ReplacementFor_MAX_LENGTH<end,true)){if(ReplacementFor_count==
(0x103+4172-0x114e))*output++=fill;else output=ReplacementFor_fill_n(output,
ReplacementFor_count,fill);}else for(ReplacementFor_uint chunkSize=static_cast<
ReplacementFor_uint>(ReplacementFor_buffer+ReplacementFor_BUFFER_SIZE-output);;
chunkSize=ReplacementFor_BUFFER_SIZE){if(chunkSize>ReplacementFor_count)
chunkSize=ReplacementFor_count;output=ReplacementFor_fill_n(output,chunkSize,
fill);ReplacementFor_flushMaybe();if((ReplacementFor_count-=chunkSize)==
(0x1683+3364-0x23a7))break;}return ReplacementFor_charsWritten;}public:
ReplacementFor_uint ReplacementFor_width;char fill;ReplacementFor_uint 
ReplacementFor_base;ReplacementFor_uint precision;unsigned long long 
ReplacementFor_basePower;string delimiter;ReplacementFor_OutputDevice(
ReplacementFor_OutputDevice const&)=delete;ReplacementFor_OutputDevice&operator=
(ReplacementFor_OutputDevice const&)=delete;virtual~ReplacementFor_OutputDevice(
){};inline int ReplacementFor_writeChar(char arg){ReplacementFor_separate=false;
*output++=arg;ReplacementFor_flushMaybe();return(0x1358+4830-0x2635);}inline int
 ReplacementFor_writeString(const char*arg,size_t length,bool 
ReplacementFor_checkWidth=true){ReplacementFor_separate=false;
ReplacementFor_uint ReplacementFor_count=static_cast<ReplacementFor_uint>(length
);int ReplacementFor_charsWritten=static_cast<int>(ReplacementFor_count)+(
ReplacementFor_checkWidth&&ReplacementFor_count<ReplacementFor_width?writeFill(
ReplacementFor_width-ReplacementFor_count):(0x2255+730-0x252f));if(
__builtin_expect(output+ReplacementFor_count+ReplacementFor_MAX_LENGTH<end,true)
){if(ReplacementFor_count==(0x110+4287-0x11ce))*output++=*arg;else output=copy_n
(arg,ReplacementFor_count,output);}else for(ReplacementFor_uint chunkSize=
static_cast<ReplacementFor_uint>(ReplacementFor_buffer+
ReplacementFor_BUFFER_SIZE-output);;chunkSize=ReplacementFor_BUFFER_SIZE){if(
chunkSize>ReplacementFor_count)chunkSize=ReplacementFor_count;output=copy_n(arg,
chunkSize,output);ReplacementFor_flushMaybe();if((ReplacementFor_count-=
chunkSize)==(0x93d+2741-0x13f2))break;arg+=chunkSize;}return 
ReplacementFor_charsWritten;}inline int ReplacementFor_writeDelimiter(){return 
ReplacementFor_writeString(delimiter.c_str(),delimiter.size(),false);}inline 
void ReplacementFor_flush(){ReplacementFor_writeToDevice(static_cast<
ReplacementFor_uint>(output-ReplacementFor_buffer));output=ReplacementFor_buffer
;}inline int write(ReplacementFor_Detail::ReplacementFor_Width 
ReplacementFor_newWidth){ReplacementFor_width=ReplacementFor_newWidth.value;
return(0x1a4+1661-0x821);}inline int write(ReplacementFor_Detail::Fill 
ReplacementFor_newFill){fill=ReplacementFor_newFill.value;return
(0x7c6+1951-0xf65);}inline int write(ReplacementFor_Detail::ReplacementFor_Base 
ReplacementFor_newBase){ReplacementFor_base=ReplacementFor_newBase.value;
ReplacementFor_computeBasePower();return(0xa89+6081-0x224a);}inline int write(
ReplacementFor_Detail::Precision ReplacementFor_newPrecision){precision=
ReplacementFor_newPrecision.value;ReplacementFor_computeBasePower();return
(0xf1c+105-0xf85);}inline int write(ReplacementFor_Detail::Delimiter 
ReplacementFor_newDelimiter){delimiter=ReplacementFor_newDelimiter.value;return
(0x305+99-0x368);}inline int write(){return(0x9fa+4313-0x1ad3);}inline int write
(char arg){return ReplacementFor_writeChar(arg);}template<class ReplacementFor_I
>inline typename enable_if<is_integral<ReplacementFor_I>::value&&
ReplacementFor_is_unsigned<ReplacementFor_I>::value,int>::type write(
ReplacementFor_I arg){return ReplacementFor_writeT(
ReplacementFor_writeUnsignedInt(arg,end));}template<class ReplacementFor_I>
inline typename enable_if<is_integral<ReplacementFor_I>::value&&
ReplacementFor_is_signed<ReplacementFor_I>::value,int>::type write(
ReplacementFor_I arg){return ReplacementFor_writeT(ReplacementFor_writeSignedInt
(arg,end));}template<class F>inline typename enable_if<is_floating_point<F>::
value,int>::type write(F arg){return ReplacementFor_writeT(
ReplacementFor_writeFloatingPoint(arg,end));}inline int write(const char*arg){
return ReplacementFor_writeString(arg,strlen(arg));}template<int 
ReplacementFor_N>inline int write(char(&arg)[ReplacementFor_N]){return 
ReplacementFor_writeString(arg,strlen(arg));}inline int write(const string&arg){
return ReplacementFor_writeString(arg.c_str(),arg.size());}template<class 
ReplacementFor_T1,class ReplacementFor_T2>inline int write(const pair<
ReplacementFor_T1,ReplacementFor_T2>&arg){int ReplacementFor_charsWritten=write(
arg.first);ReplacementFor_charsWritten+=ReplacementFor_writeDelimiter();return 
ReplacementFor_charsWritten+write(arg.second);}template<class ReplacementFor_T>
inline int write(const ReplacementFor_complex<ReplacementFor_T>&arg){return 
write(ReplacementFor_real(arg),ReplacementFor_imag(arg));}template<class 
ReplacementFor_Iterator,class...ReplacementFor_Ts>inline typename enable_if<
ReplacementFor_is_iterator<ReplacementFor_Iterator>::value,int>::type write(
ReplacementFor_Iterator first,ReplacementFor_Iterator last,ReplacementFor_Ts&&
...ReplacementFor_args){int ReplacementFor_charsWritten=(0x3e8+1360-0x938);for(;
first!=last;ReplacementFor_charsWritten+=++first==last?(0x3e4+3767-0x129b):
ReplacementFor_writeDelimiter())ReplacementFor_charsWritten+=write(*first);
return ReplacementFor_charsWritten+write(forward<ReplacementFor_Ts>(
ReplacementFor_args)...);}template<class ReplacementFor_Iterator,class 
ReplacementFor_I,class...ReplacementFor_Ts>inline typename enable_if<
ReplacementFor_is_iterator<ReplacementFor_Iterator>::value&&is_integral<
ReplacementFor_I>::value,int>::type write(ReplacementFor_Iterator first,
ReplacementFor_I ReplacementFor_count,ReplacementFor_Ts&&...ReplacementFor_args)
{return write(first,first+ReplacementFor_count,forward<ReplacementFor_Ts>(
ReplacementFor_args)...);}template<class ReplacementFor_T>inline auto write(
const ReplacementFor_T&arg)->decltype(arg.write(*this)){return arg.write(*this);
}template<class ReplacementFor_T0,class ReplacementFor_T1,class...
ReplacementFor_Ts>inline typename enable_if<!ReplacementFor_is_iterator<
ReplacementFor_T0>::value,int>::type write(ReplacementFor_T0&&
ReplacementFor_arg0,ReplacementFor_T1&&ReplacementFor_arg1,ReplacementFor_Ts&&
...ReplacementFor_args){int ReplacementFor_charsWritten=write(forward<
ReplacementFor_T0>(ReplacementFor_arg0));return ReplacementFor_charsWritten+
write(forward<ReplacementFor_T1>(ReplacementFor_arg1),forward<ReplacementFor_Ts>
(ReplacementFor_args)...);}};class ReplacementFor_OutputFile:public 
ReplacementFor_OutputDevice{FILE*file;bool ReplacementFor_owner;void 
ReplacementFor_writeToDevice(ReplacementFor_uint ReplacementFor_count)override{
fwrite(ReplacementFor_buffer,(0x199d+1791-0x209b),ReplacementFor_count,file);
fflush(file);}public:ReplacementFor_OutputFile(FILE*file=stdout,bool 
ReplacementFor_takeOwnership=false):file(file),ReplacementFor_owner(
ReplacementFor_takeOwnership){}ReplacementFor_OutputFile(const char*
ReplacementFor_fileName):ReplacementFor_OutputFile(fopen(ReplacementFor_fileName
,"\x77"),true){}~ReplacementFor_OutputFile()override{ReplacementFor_flush();if(
ReplacementFor_owner)fclose(file);}};class ReplacementFor_OutputString:public 
ReplacementFor_OutputDevice{string&str;void ReplacementFor_writeToDevice(
ReplacementFor_uint ReplacementFor_count)override{str.ReplacementFor_append(
ReplacementFor_buffer,ReplacementFor_count);}public:ReplacementFor_OutputString(
string&str):ReplacementFor_OutputDevice(),str(str){}~ReplacementFor_OutputString
()override{ReplacementFor_flush();}};ReplacementFor_unique_ptr<
ReplacementFor_InputFile>input;ReplacementFor_unique_ptr<
ReplacementFor_OutputFile>output;ReplacementFor_unique_ptr<
ReplacementFor_OutputFile>logs;template<class...ReplacementFor_Ts>inline void 
read(ReplacementFor_Ts&&...ReplacementFor_args){assert(input->read(forward<
ReplacementFor_Ts>(ReplacementFor_args)...));}template<class...ReplacementFor_Ts
>inline void ReplacementFor_writeln(ReplacementFor_Ts&&...ReplacementFor_args){
logs->write(forward<ReplacementFor_Ts>(ReplacementFor_args)...,'\n');logs->
ReplacementFor_flush();}class TestCase{public:static const int ReplacementFor_N=
(0x23c6+1852-0x26ab);int ReplacementFor_d,ReplacementFor_n,ReplacementFor_k[
ReplacementFor_N],s[ReplacementFor_N];void input(){read(ReplacementFor_d,
ReplacementFor_n);ReplacementFor_REP(ReplacementFor_i,ReplacementFor_n)read(
ReplacementFor_k[ReplacementFor_i],s[ReplacementFor_i]);}void generate(bool 
ReplacementFor_big,int ReplacementFor_seed){auto rnd=bind(
ReplacementFor_uniform_int_distribution<int>((0x1a2d+3188-0x26a1),
(0x13b5+3900-0x22e8)),ReplacementFor_default_random_engine(ReplacementFor_seed))
;}void solveSlow(){output->ReplacementFor_flush();}void solve(){double last=
(0xa51+4777-0x1cfa);ReplacementFor_REP(ReplacementFor_i,ReplacementFor_n)
ReplacementFor_smax(last,double(ReplacementFor_d-ReplacementFor_k[
ReplacementFor_i])/s[ReplacementFor_i]);write(ReplacementFor_d/last);output->
ReplacementFor_flush();}string outputStr;TestCase():output(new 
ReplacementFor_OutputString(outputStr)){};private:ReplacementFor_unique_ptr<
ReplacementFor_OutputDevice>output;template<class...ReplacementFor_Ts>inline int
 write(ReplacementFor_Ts&&...ReplacementFor_args){return output->write(forward<
ReplacementFor_Ts>(ReplacementFor_args)...);}template<class...ReplacementFor_Ts>
inline int ReplacementFor_writeln(ReplacementFor_Ts&&...ReplacementFor_args){
return write(forward<ReplacementFor_Ts>(ReplacementFor_args)...,'\n');}};mutex 
inputMutex;int ReplacementFor_testIndex,ReplacementFor_testCount;vector<string>
answer;void ReplacementFor_work(){while(true){inputMutex.ReplacementFor_lock();
if(ReplacementFor_testIndex>=ReplacementFor_testCount){inputMutex.unlock();break
;}int ReplacementFor_current=ReplacementFor_testIndex++;ReplacementFor_writeln(
"\x43\x61\x73\x65\x20",ReplacementFor_current+(0x1253+4487-0x23d9),
"\x20\x73\x74\x61\x72\x74\x65\x64");ReplacementFor_unique_ptr<TestCase>test(new 
TestCase());test->input();inputMutex.unlock();test->solve();answer[
ReplacementFor_current].swap(test->outputStr);}}void ReplacementFor_writeAnswer(
int test,const string&answer){output->write("\x43\x61\x73\x65\x20\x23",test+
(0x1446+3921-0x2396),"\x3a\x20",answer,"\n");output->ReplacementFor_flush();}
void ReplacementFor_randomTest(){for(int ReplacementFor_i=(0xa59+6687-0x2478);
ReplacementFor_i<(0x921+6886-0x23a3);++ReplacementFor_i){
ReplacementFor_unique_ptr<TestCase>test(new TestCase());test->generate(false,
ReplacementFor_i);test->solve();string output;output.swap(test->outputStr);test
->solveSlow();if(test->outputStr!=output){ReplacementFor_writeln(
"\x45\x72\x72\x6f\x72\x20\x6f\x6e\x20\x74\x65\x73\x74\x20\x23",ReplacementFor_i+
(0x1340+2492-0x1cfb));ReplacementFor_writeln(
"\x45\x78\x70\x65\x63\x74\x65\x64\x3a" "\n",test->outputStr);
ReplacementFor_writeln("\x52\x65\x63\x65\x69\x76\x65\x64\x3a" "\n",output);}}
ReplacementFor_writeln("\n\n" "\x54\x65\x73\x74\x20\x74\x69\x6d\x65\x3a\x20",
static_cast<double>(clock())/CLOCKS_PER_SEC);exit((0x13c8+409-0x1561));}void 
ReplacementFor_maxTest(){for(int ReplacementFor_i=(0x988+4576-0x1b68);
ReplacementFor_i<(0xb15+6196-0x22e5);++ReplacementFor_i){
ReplacementFor_unique_ptr<TestCase>test(new TestCase());test->generate(true,
ReplacementFor_i);test->solve();ReplacementFor_writeAnswer(ReplacementFor_i,test
->outputStr);}ReplacementFor_writeln(
"\n\n" "\x54\x65\x73\x74\x20\x74\x69\x6d\x65\x3a\x20",static_cast<double>(clock(
))/CLOCKS_PER_SEC);exit((0x2551+373-0x26c6));}int main(){input.
ReplacementFor_reset(new ReplacementFor_InputFile(
"\x41\x2d\x6c\x61\x72\x67\x65\x2e\x69\x6e"));output.ReplacementFor_reset(new 
ReplacementFor_OutputFile("\x6f\x75\x74\x70\x75\x74\x2e\x74\x78\x74"));logs.
ReplacementFor_reset(new ReplacementFor_OutputFile(stderr));logs->write(
setPrecision((0xf85+2628-0x19c5)));ReplacementFor_testIndex=(0x1047+720-0x1317);
input->read(ReplacementFor_testCount);answer.resize(ReplacementFor_testCount);
#ifndef ReplacementFor_SINGLE_THREAD
vector<thread>threads;for(int ReplacementFor_i=(0x43a+4949-0x178f);
ReplacementFor_i<thread::hardware_concurrency();++ReplacementFor_i)threads.
emplace_back(ReplacementFor_work);for(auto&thread:threads)thread.join();for(int 
ReplacementFor_i=(0x1696+1317-0x1bbb);ReplacementFor_i<ReplacementFor_testCount;
++ReplacementFor_i)ReplacementFor_writeAnswer(ReplacementFor_i,answer[
ReplacementFor_i]);
#else
for(int ReplacementFor_i=(0xe46+6050-0x25e8);ReplacementFor_i<
ReplacementFor_testCount;++ReplacementFor_i){ReplacementFor_writeln(
"\x43\x61\x73\x65\x20",ReplacementFor_i+(0xac8+2904-0x161f),
"\x20\x73\x74\x61\x72\x74\x65\x64");ReplacementFor_unique_ptr<TestCase>test(new 
TestCase());test->input();test->solve();ReplacementFor_writeAnswer(
ReplacementFor_i,test->outputStr);}
#endif
ReplacementFor_writeln("\n\n" "\x54\x6f\x74\x61\x6c\x20\x74\x69\x6d\x65\x3a\x20"
,static_cast<double>(clock())/CLOCKS_PER_SEC);return(0x362+5136-0x1772);}
