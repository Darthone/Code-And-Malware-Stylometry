
#define ASSERT(...) assert(ReplacementFor___VA_ARGS__)
#include <stdexcept>
#include <iostream>
#include <iomanip>
#include <sstream>
#include <fstream>
#include <cassert>
#include <cstring>
#include <cstdarg>
#include <cstdio>
#include <memory>
#include <random>
#include <cmath>
#include <ctime>
#include <unordered_map>
#include <unordered_set>
#include <functional>
#include <algorithm>
#include <complex>
#include <numeric>
#include <limits>
#include <bitset>
#include <vector>
#include <string>
#include <queue>
#include <deque>
#include <array>
#include <list>
#include <map>
#include <set>
#include <thread>
#include <mutex>
using namespace std;
#define ReplacementFor_all(a) (a).begin(), (a).end()
#define ReplacementFor_sz(a) static_cast<int>((a).size())
#define FOR(ReplacementFor_i, a, ReplacementFor_b) for (int ReplacementFor_i(a),\
 ReplacementFor_b_(ReplacementFor_b); ReplacementFor_i < ReplacementFor_b_; ++\
ReplacementFor_i)
#define ReplacementFor_REP(ReplacementFor_i, ReplacementFor_n) FOR (\
ReplacementFor_i, (0x8ad+4257-0x194e), ReplacementFor_n)
#define ReplacementFor_FORD(ReplacementFor_i, a, ReplacementFor_b) for (int \
ReplacementFor_i(a), ReplacementFor_b_(ReplacementFor_b); ReplacementFor_i >= \
ReplacementFor_b_; --ReplacementFor_i)
#define UNIQUE(a) sort(ReplacementFor_all(a)), (a).ReplacementFor_erase(unique(\
ReplacementFor_all(a)), (a).end())
#define ReplacementFor_CL(a, ReplacementFor_v) memset(a, ReplacementFor_v, \
sizeof a)
#define ReplacementFor_eb emplace_back
#define ReplacementFor_pb push_back
#define ReplacementFor_X first
#define ReplacementFor_Y second
typedef long long ReplacementFor_ll;typedef long double ReplacementFor_ld;
typedef vector<int>ReplacementFor_vi;typedef pair<int,int>ReplacementFor_pii;
template<class ReplacementFor_T>using ReplacementFor_min_queue=priority_queue<
ReplacementFor_T,vector<ReplacementFor_T>,greater<ReplacementFor_T>>;const int 
ReplacementFor_INF=static_cast<int>(1e9);const long long ReplacementFor_INF_LL=
static_cast<long long>(4e18);const double ReplacementFor_pi=acos(-1.0);template<
class ReplacementFor_T>ReplacementFor_T&ReplacementFor_smin(ReplacementFor_T&
ReplacementFor_x,const ReplacementFor_T&ReplacementFor_y){if(ReplacementFor_x>
ReplacementFor_y)ReplacementFor_x=ReplacementFor_y;return ReplacementFor_x;}
template<class ReplacementFor_T>ReplacementFor_T&ReplacementFor_smax(
ReplacementFor_T&ReplacementFor_x,const ReplacementFor_T&ReplacementFor_y){if(
ReplacementFor_x<ReplacementFor_y)ReplacementFor_x=ReplacementFor_y;return 
ReplacementFor_x;}template<class ReplacementFor_T>ReplacementFor_T 
ReplacementFor_sqr(const ReplacementFor_T&ReplacementFor_x){return 
ReplacementFor_x*ReplacementFor_x;}template<class ReplacementFor_T>inline int 
ReplacementFor_sgn(const ReplacementFor_T&ReplacementFor_x){return(
ReplacementFor_T((0x2110+886-0x2486))<ReplacementFor_x)-(ReplacementFor_x<
ReplacementFor_T((0x1405+2937-0x1f7e)));}template<class ReplacementFor_T>
ReplacementFor_T ReplacementFor_gcd(ReplacementFor_T a,ReplacementFor_T 
ReplacementFor_b){for(a=ReplacementFor_abs(a),ReplacementFor_b=
ReplacementFor_abs(ReplacementFor_b);a&&ReplacementFor_b;a>=ReplacementFor_b?a%=
ReplacementFor_b:ReplacementFor_b%=a);return a+ReplacementFor_b;}template<class 
ReplacementFor_T>struct ReplacementFor_is_commutative{constexpr static bool 
value=true;};template<class ReplacementFor_T>struct ReplacementFor_is_iterator{
template<class ReplacementFor_U,typename enable_if<!is_convertible<
ReplacementFor_U,const char*>::value,int>::type=(0x40d+1161-0x896)>constexpr 
static auto ReplacementFor_has_indirection(int)->decltype(*declval<
ReplacementFor_U>(),bool()){return true;}template<class>constexpr static bool 
ReplacementFor_has_indirection(long){return false;}constexpr static bool value=
ReplacementFor_has_indirection<ReplacementFor_T>((0x187+8922-0x2461));};using 
ReplacementFor_uint=unsigned int;const ReplacementFor_uint 
ReplacementFor_BUFFER_SIZE=(0x66a+4711-0x18d0)<<(0xa51+4533-0x1bfa);const 
ReplacementFor_uint ReplacementFor_MAX_LENGTH=(0x1555+1582-0x1b82)<<
(0x16cd+1545-0x1ccf);namespace ReplacementFor_Detail{struct ReplacementFor_Width
{ReplacementFor_uint value;};struct Fill{char value;};struct ReplacementFor_Base
{ReplacementFor_uint value;};struct Precision{ReplacementFor_uint value;};struct
 Delimiter{const char*value;};}ReplacementFor_Detail::ReplacementFor_Width 
ReplacementFor_setWidth(ReplacementFor_uint value=(0x1788+3338-0x2492)){return{
value};}ReplacementFor_Detail::Fill ReplacementFor_setFill(char value=
((char)(0x4b+4226-0x10ad))){return{value};}ReplacementFor_Detail::
ReplacementFor_Base ReplacementFor_setBase(ReplacementFor_uint value=
(0xe0+1107-0x529)){assert((0x161+1087-0x59e)<=value&&value<=(0x760+3601-0x154d))
;return{value};}ReplacementFor_Detail::Precision setPrecision(
ReplacementFor_uint value=(0x356+6729-0x1d96)){assert(value<
ReplacementFor_MAX_LENGTH);return{value};}ReplacementFor_Detail::Delimiter 
ReplacementFor_setDelimiter(const char*value="\x20"){return{value};}class 
InputDevice{protected:const char*ReplacementFor_head;const char*
ReplacementFor_tail;InputDevice(const char*ReplacementFor_head,const char*
ReplacementFor_tail):ReplacementFor_head(ReplacementFor_head),
ReplacementFor_tail(ReplacementFor_tail),ReplacementFor_base(
ReplacementFor_setBase().value){}virtual void ReplacementFor_fillInput()=0;
inline char nextChar(){if(__builtin_expect(ReplacementFor_head>=
ReplacementFor_tail,false))ReplacementFor_fillInput();return*ReplacementFor_head
++;}template<class ReplacementFor_I>int ReplacementFor_readUnsignedIntGeneral(
ReplacementFor_I&arg,char ReplacementFor_c){ReplacementFor_I value=
(0x28+3220-0xcbc);int length=(0x18bd+2656-0x231d);for(;;++length,
ReplacementFor_c=nextChar()){if(ReplacementFor_isDigit(ReplacementFor_c))
ReplacementFor_c-=((char)(0x147a+743-0x1731));else if(ReplacementFor_isUpper(
ReplacementFor_c))ReplacementFor_c-=((char)(0x968+1300-0xe3b))-
(0xfc9+840-0x1307);else if(ReplacementFor_isLower(ReplacementFor_c))
ReplacementFor_c-=((char)(0x897+6225-0x2087))-(0x15fc+566-0x1828);else 
ReplacementFor_c=ReplacementFor_base;if(ReplacementFor_c>=ReplacementFor_base)
break;value=ReplacementFor_base*value+ReplacementFor_c;}arg=value;return--
ReplacementFor_head,length;}template<class ReplacementFor_I>inline int 
ReplacementFor_readUnsignedInt(ReplacementFor_I&arg,char ReplacementFor_c){if(
__builtin_expect(ReplacementFor_base>(0x1749+541-0x195c),false))return 
ReplacementFor_readUnsignedIntGeneral(arg,ReplacementFor_c);ReplacementFor_I 
value=(0x157f+3080-0x2187);int length=(0x1861+1653-0x1ed6);for(;static_cast<
unsigned char>(ReplacementFor_c-((char)(0x1526+2109-0x1d33)))<
ReplacementFor_base;++length,ReplacementFor_c=nextChar())value=
ReplacementFor_base*value+ReplacementFor_c-((char)(0x3d3+3105-0xfc4));arg=value;
return--ReplacementFor_head,length;}template<class ReplacementFor_I>inline bool 
ReplacementFor_readSignedInt(ReplacementFor_I&arg,char ReplacementFor_c){bool 
ReplacementFor_negative=ReplacementFor_c==((char)(0x33b+1821-0xa2b));if(
ReplacementFor_negative)ReplacementFor_c=nextChar();typename make_unsigned<
ReplacementFor_I>::type unsignedArg;if(ReplacementFor_readUnsignedInt(
unsignedArg,ReplacementFor_c)==(0x3e3+7295-0x2062))return false;arg=
ReplacementFor_negative?~static_cast<ReplacementFor_I>(unsignedArg-
(0x1203+1017-0x15fb)):static_cast<ReplacementFor_I>(unsignedArg);return true;}
template<class F>bool ReplacementFor_readFloatingPoint(F&arg,char 
ReplacementFor_c){bool ReplacementFor_negative=ReplacementFor_c==
((char)(0xcd+2253-0x96d));if(ReplacementFor_negative)ReplacementFor_c=nextChar()
;unsigned long long ReplacementFor_integerPart;if(ReplacementFor_readUnsignedInt
(ReplacementFor_integerPart,ReplacementFor_c)==(0x2b2+5720-0x190a))return false;
arg=static_cast<F>(ReplacementFor_integerPart);if(nextChar()==
((char)(0xa1c+4361-0x1af7))){unsigned long long ReplacementFor_fractionalPart=
(0x161c+3145-0x2265);int ReplacementFor_fractionalLength=
ReplacementFor_readUnsignedInt(ReplacementFor_fractionalPart,nextChar());if(
ReplacementFor_fractionalLength>(0x2189+232-0x2271)){unsigned long long 
ReplacementFor_basePower=(0x1a22+2765-0x24ee);for(;
ReplacementFor_fractionalLength;--ReplacementFor_fractionalLength)
ReplacementFor_basePower*=ReplacementFor_base;arg+=static_cast<F>(
ReplacementFor_fractionalPart)/ReplacementFor_basePower;}}else--
ReplacementFor_head;if(ReplacementFor_negative)arg=-arg;return true;}public:
ReplacementFor_uint ReplacementFor_base;InputDevice(InputDevice const&)=delete;
InputDevice&operator=(InputDevice const&)=delete;static inline bool 
ReplacementFor_isSpace(char ReplacementFor_c){return static_cast<unsigned char>(
ReplacementFor_c-'\t')<(0x864+5715-0x1eb2)||ReplacementFor_c==
((char)(0x7da+3613-0x15d7));}static inline bool ReplacementFor_isDigit(char 
ReplacementFor_c){return static_cast<unsigned char>(ReplacementFor_c-
((char)(0xb05+6404-0x23d9)))<(0x794+7708-0x25a6);}static inline bool 
ReplacementFor_isUpper(char ReplacementFor_c){return static_cast<unsigned char>(
ReplacementFor_c-((char)(0x2e5+899-0x627)))<(0x72c+806-0xa38);}static inline 
bool ReplacementFor_isLower(char ReplacementFor_c){return static_cast<unsigned 
char>(ReplacementFor_c-((char)(0x3a1+2566-0xd46)))<(0x1ac0+2141-0x2303);}static 
inline bool ReplacementFor_isOneOf(char ReplacementFor_c,const char*str){return 
strchr(str,ReplacementFor_c)!=nullptr;}void ReplacementFor_putBack(){--
ReplacementFor_head;}inline bool ReplacementFor_readChar(char&arg){if(
__builtin_expect(ReplacementFor_head>=ReplacementFor_tail,false)){
ReplacementFor_fillInput();if(__builtin_expect(ReplacementFor_head>=
ReplacementFor_tail,false))return arg='\0',false;}return arg=*
ReplacementFor_head++,true;}template<class ReplacementFor_UnaryPredicate>inline 
char ReplacementFor_skipCharacters(ReplacementFor_UnaryPredicate 
ReplacementFor_isSkipped){char ReplacementFor_c;do{ReplacementFor_c=nextChar();}
while(ReplacementFor_isSkipped(ReplacementFor_c));return ReplacementFor_c;}
inline char ReplacementFor_skipCharacters(){return ReplacementFor_skipCharacters
(ReplacementFor_isSpace);}template<class ReplacementFor_UnaryPredicate>inline 
int ReplacementFor_readString(char*arg,int ReplacementFor_limit,
ReplacementFor_UnaryPredicate ReplacementFor_isTerminator,bool 
ReplacementFor_skip){int ReplacementFor_charsRead=(0x120a+1770-0x18f4);if(
ReplacementFor_skip)ReplacementFor_skipCharacters(ReplacementFor_isTerminator),
--ReplacementFor_head;for(--ReplacementFor_limit;ReplacementFor_head<
ReplacementFor_tail;ReplacementFor_fillInput()){ReplacementFor_ptrdiff_t 
chunkSize=ReplacementFor_find_if(ReplacementFor_head,min(ReplacementFor_tail,
ReplacementFor_head+ReplacementFor_limit-ReplacementFor_charsRead),
ReplacementFor_isTerminator)-ReplacementFor_head;arg=copy_n(ReplacementFor_head,
chunkSize,arg);ReplacementFor_head+=chunkSize;ReplacementFor_charsRead+=
chunkSize;if(chunkSize==(0xa14+4970-0x1d7e)||ReplacementFor_head<
ReplacementFor_tail)break;}return*arg='\0',ReplacementFor_charsRead;}inline int 
ReplacementFor_readString(char*arg,int ReplacementFor_limit,const char*
ReplacementFor_terminators,bool ReplacementFor_skip){if(!*
ReplacementFor_terminators)return ReplacementFor_readString(arg,
ReplacementFor_limit,InputDevice::ReplacementFor_isSpace,ReplacementFor_skip);
return ReplacementFor_readString(arg,ReplacementFor_limit,[
ReplacementFor_terminators](char ReplacementFor_c){return InputDevice::
ReplacementFor_isOneOf(ReplacementFor_c,ReplacementFor_terminators);},
ReplacementFor_skip);}inline bool read(ReplacementFor_Detail::
ReplacementFor_Base ReplacementFor_newBase){ReplacementFor_base=
ReplacementFor_newBase.value;return true;}inline bool read(){return true;}inline
 bool read(char&arg){return ReplacementFor_readChar(arg);}template<class 
ReplacementFor_I>inline typename enable_if<is_integral<ReplacementFor_I>::value
&&ReplacementFor_is_unsigned<ReplacementFor_I>::value,bool>::type read(
ReplacementFor_I&arg){return ReplacementFor_readUnsignedInt(arg,
ReplacementFor_skipCharacters())>(0x1ca+6534-0x1b50);}template<class 
ReplacementFor_I>inline typename enable_if<is_integral<ReplacementFor_I>::value
&&ReplacementFor_is_signed<ReplacementFor_I>::value,bool>::type read(
ReplacementFor_I&arg){return ReplacementFor_readSignedInt(arg,
ReplacementFor_skipCharacters());}template<class F>inline typename enable_if<
is_floating_point<F>::value,bool>::type read(F&arg){return 
ReplacementFor_readFloatingPoint(arg,ReplacementFor_skipCharacters());}inline 
bool read(const char&arg){ReplacementFor_skipCharacters([arg](char 
ReplacementFor_c){return arg!=ReplacementFor_c;});return true;}inline bool read(
const char*arg){if(*arg)ReplacementFor_skipCharacters([arg](char 
ReplacementFor_c){return InputDevice::ReplacementFor_isOneOf(ReplacementFor_c,
arg);});else ReplacementFor_skipCharacters();return ReplacementFor_putBack(),
true;}inline bool read(bool(*ReplacementFor_isSkipped)(char)){
ReplacementFor_skipCharacters(ReplacementFor_isSkipped);ReplacementFor_putBack()
;return true;}template<class ReplacementFor_I,class ReplacementFor_Terminator,
class...ReplacementFor_Ts>inline typename enable_if<is_integral<ReplacementFor_I
>::value,bool>::type read(char*arg,ReplacementFor_I ReplacementFor_limit,
ReplacementFor_Terminator ReplacementFor_terminator,ReplacementFor_Ts&&...
ReplacementFor_args){ReplacementFor_readString(arg,static_cast<int>(
ReplacementFor_limit),ReplacementFor_terminator,true);return read(forward<
ReplacementFor_Ts>(ReplacementFor_args)...);}template<class ReplacementFor_I>
inline typename enable_if<is_integral<ReplacementFor_I>::value,bool>::type read(
char*arg,ReplacementFor_I ReplacementFor_limit){return read(arg,
ReplacementFor_limit,"");}template<class...ReplacementFor_Ts>inline bool read(
char*first,char*last,ReplacementFor_Ts&&...ReplacementFor_args){return read(
first,static_cast<int>(last-first),forward<ReplacementFor_Ts>(
ReplacementFor_args)...);}template<int ReplacementFor_N,class...
ReplacementFor_Ts>inline bool read(char(&arg)[ReplacementFor_N],
ReplacementFor_Ts&&...ReplacementFor_args){return read(static_cast<char*>(arg),
ReplacementFor_N,forward<ReplacementFor_Ts>(ReplacementFor_args)...);}template<
class ReplacementFor_Terminator,class...ReplacementFor_Ts>inline bool read(
string&arg,ReplacementFor_Terminator ReplacementFor_terminator,ReplacementFor_Ts
&&...ReplacementFor_args){for(int length=max((0xb0f+5760-0x217f),static_cast<int
>(arg.capacity())),last=(0x364+3260-0x1020);;length=last+=length){arg.resize(
last+length);int ReplacementFor_charsRead=ReplacementFor_readString(&arg[last],
length+(0x389+692-0x63c),ReplacementFor_terminator,last==(0xaf6+5824-0x21b6));if
(ReplacementFor_charsRead<length){arg.resize(last+ReplacementFor_charsRead);
return read(forward<ReplacementFor_Ts>(ReplacementFor_args)...);}}}inline bool 
read(string&arg){return read(arg,"");}template<class ReplacementFor_T1,class 
ReplacementFor_T2>inline bool read(pair<ReplacementFor_T1,ReplacementFor_T2>&arg
){return read(arg.first,arg.second);}template<class ReplacementFor_T>inline bool
 read(ReplacementFor_complex<ReplacementFor_T>&arg){ReplacementFor_T 
ReplacementFor_real,ReplacementFor_imag;if(!read(ReplacementFor_real,
ReplacementFor_imag))return false;arg.ReplacementFor_real(ReplacementFor_real),
arg.ReplacementFor_imag(ReplacementFor_imag);return true;}template<class 
ReplacementFor_T>inline bool read(vector<ReplacementFor_T>&arg){
ReplacementFor_uint ReplacementFor_n;if(!read(ReplacementFor_n))return false;arg
.resize(ReplacementFor_n);return read(arg.begin(),arg.end());}template<class 
ReplacementFor_Iterator,class...ReplacementFor_Ts>inline typename enable_if<
ReplacementFor_is_iterator<ReplacementFor_Iterator>::value,bool>::type read(
ReplacementFor_Iterator first,ReplacementFor_Iterator last,ReplacementFor_Ts&&
...ReplacementFor_args){for(;first!=last;++first)if(!read(*first))return false;
return read(forward<ReplacementFor_Ts>(ReplacementFor_args)...);}template<class 
ReplacementFor_Iterator,class ReplacementFor_I,class...ReplacementFor_Ts>inline 
typename enable_if<ReplacementFor_is_iterator<ReplacementFor_Iterator>::value&&
is_integral<ReplacementFor_I>::value,bool>::type read(ReplacementFor_Iterator 
first,ReplacementFor_I ReplacementFor_count,ReplacementFor_Ts&&...
ReplacementFor_args){return read(first,first+ReplacementFor_count,forward<
ReplacementFor_Ts>(ReplacementFor_args)...);}template<class ReplacementFor_T>
inline auto read(ReplacementFor_T&arg)->decltype(arg.read(*this)){return arg.
read(*this);}template<class ReplacementFor_T0,class ReplacementFor_T1,class...
ReplacementFor_Ts>inline typename enable_if<!ReplacementFor_is_iterator<
ReplacementFor_T0>::value&&!is_convertible<ReplacementFor_T0,char*>::value,bool>
::type read(ReplacementFor_T0&&ReplacementFor_arg0,ReplacementFor_T1&&
ReplacementFor_arg1,ReplacementFor_Ts&&...ReplacementFor_args){return read(
forward<ReplacementFor_T0>(ReplacementFor_arg0))&&read(forward<ReplacementFor_T1
>(ReplacementFor_arg1),forward<ReplacementFor_Ts>(ReplacementFor_args)...);}};
class ReplacementFor_InputFile:public InputDevice{FILE*file;bool 
ReplacementFor_lineBuffered;bool ReplacementFor_owner;char ReplacementFor_buffer
[ReplacementFor_BUFFER_SIZE];void ReplacementFor_fillInput()override{
ReplacementFor_head=ReplacementFor_buffer;*ReplacementFor_buffer='\0';if(
__builtin_expect(!ReplacementFor_lineBuffered,true)){ReplacementFor_tail=
ReplacementFor_head+fread(ReplacementFor_buffer,(0xe8+5305-0x15a0),
ReplacementFor_BUFFER_SIZE,file);}else{ReplacementFor_tail=ReplacementFor_head;
if(fgets(ReplacementFor_buffer,ReplacementFor_BUFFER_SIZE,file))while(*
ReplacementFor_tail)++ReplacementFor_tail;}}public:ReplacementFor_InputFile(FILE
*file=stdin,bool ReplacementFor_lineBuffered=true,bool 
ReplacementFor_takeOwnership=false):InputDevice(ReplacementFor_buffer,
ReplacementFor_buffer),file(file),ReplacementFor_lineBuffered(
ReplacementFor_lineBuffered),ReplacementFor_owner(ReplacementFor_takeOwnership){
}ReplacementFor_InputFile(const char*ReplacementFor_fileName):
ReplacementFor_InputFile(fopen(ReplacementFor_fileName,"\x72"),false,true){}~
ReplacementFor_InputFile(){if(ReplacementFor_owner)fclose(file);}};class 
ReplacementFor_InputString:public InputDevice{void ReplacementFor_fillInput()
override{while(*ReplacementFor_tail)++ReplacementFor_tail;}public:
ReplacementFor_InputString(const string&s):InputDevice(s.ReplacementFor_data(),s
.ReplacementFor_data()+s.size()){}ReplacementFor_InputString(const char*s):
InputDevice(s,s+strlen(s)){}};class ReplacementFor_OutputDevice{protected:char 
ReplacementFor_buffer[ReplacementFor_BUFFER_SIZE+ReplacementFor_MAX_LENGTH];char
*output;char*end;bool ReplacementFor_separate;ReplacementFor_OutputDevice():
output(ReplacementFor_buffer),end(ReplacementFor_buffer+
ReplacementFor_BUFFER_SIZE+ReplacementFor_MAX_LENGTH),ReplacementFor_separate(
false),ReplacementFor_width(ReplacementFor_setWidth().value),fill(
ReplacementFor_setFill().value),ReplacementFor_base(ReplacementFor_setBase().
value),precision(setPrecision().value),delimiter(ReplacementFor_setDelimiter().
value){ReplacementFor_computeBasePower();}virtual void 
ReplacementFor_writeToDevice(ReplacementFor_uint ReplacementFor_count)=0;inline 
void ReplacementFor_flushMaybe(){if(__builtin_expect(output>=
ReplacementFor_buffer+ReplacementFor_BUFFER_SIZE,false)){
ReplacementFor_writeToDevice(ReplacementFor_BUFFER_SIZE);output=copy(
ReplacementFor_buffer+ReplacementFor_BUFFER_SIZE,output,ReplacementFor_buffer);}
}void ReplacementFor_computeBasePower(){ReplacementFor_basePower=
(0x9d4+2461-0x1370);for(ReplacementFor_uint ReplacementFor_i=(0xedb+404-0x106f);
ReplacementFor_i<precision;++ReplacementFor_i)ReplacementFor_basePower*=
ReplacementFor_base;}template<class ReplacementFor_I>inline char*
ReplacementFor_writeUnsignedInt(ReplacementFor_I arg,char*last){if(
__builtin_expect(arg==(0x380+7450-0x209a),false))*--last=
((char)(0xb25+3627-0x1920));if(__builtin_expect(ReplacementFor_base==
(0x1542+182-0x15ee),true)){for(;arg;arg/=(0x1033+982-0x13ff))*--last=
((char)(0x1110+699-0x139b))+arg%(0x111a+4663-0x2347);}else for(;arg;arg/=
ReplacementFor_base){ReplacementFor_I ReplacementFor_digit=arg%
ReplacementFor_base;*--last=ReplacementFor_digit<(0x453+4118-0x145f)?
((char)(0x732+2192-0xf92))+ReplacementFor_digit:((char)(0x76f+71-0x775))-
(0x13ef+1159-0x186c)+ReplacementFor_digit;}return last;}template<class 
ReplacementFor_I>inline char*ReplacementFor_writeSignedInt(ReplacementFor_I arg,
char*last){auto unsignedArg=static_cast<typename make_unsigned<ReplacementFor_I>
::type>(arg);if(arg<(0x2035+302-0x2163)){last=ReplacementFor_writeUnsignedInt(~
unsignedArg+(0x1d8+3348-0xeeb),last);*--last=((char)(0x79+1175-0x4e3));return 
last;}return ReplacementFor_writeUnsignedInt(unsignedArg,last);}template<class F
>char*ReplacementFor_writeFloatingPoint(F arg,char*last){bool 
ReplacementFor_negative=ReplacementFor_signbit(arg);if(ReplacementFor_negative)
arg=-arg;if(ReplacementFor_isnan(arg))for(int ReplacementFor_i=
(0x9a8+5307-0x1e63);ReplacementFor_i<(0xe34+4144-0x1e61);++ReplacementFor_i)*--
last=ReplacementFor_i["\x4e\x61\x4e"];else if(ReplacementFor_isinf(arg))for(int 
ReplacementFor_i=(0x188f+484-0x1a73);ReplacementFor_i<(0x1a87+1766-0x216a);++
ReplacementFor_i)*--last=ReplacementFor_i["\x66\x6e\x49"];else{auto 
ReplacementFor_integerPart=static_cast<unsigned long long>(arg);auto 
ReplacementFor_fractionalPart=static_cast<unsigned long long>((arg-
ReplacementFor_integerPart)*ReplacementFor_basePower+F(0.5));if(
ReplacementFor_fractionalPart>=ReplacementFor_basePower)++
ReplacementFor_integerPart,ReplacementFor_fractionalPart=(0x1301+1064-0x1729);
char*ReplacementFor_point=last-precision;if(precision>(0x1a53+1108-0x1ea7)){::
fill(ReplacementFor_point,ReplacementFor_writeUnsignedInt(
ReplacementFor_fractionalPart,last),((char)(0x2058+1605-0x266d)));*--
ReplacementFor_point=((char)(0xffa+397-0x1159));}last=
ReplacementFor_writeUnsignedInt(ReplacementFor_integerPart,ReplacementFor_point)
;}if(ReplacementFor_negative)*--last=((char)(0x1801+3265-0x2495));return last;}
inline int ReplacementFor_writeT(char*first){int ReplacementFor_delimiterLength=
ReplacementFor_separate?ReplacementFor_writeDelimiter():(0x233+8917-0x2508);
ReplacementFor_separate=true;ReplacementFor_uint ReplacementFor_charsWritten=
static_cast<ReplacementFor_uint>(end-first);if(__builtin_expect(
ReplacementFor_charsWritten<ReplacementFor_width,false))
ReplacementFor_charsWritten+=writeFill(ReplacementFor_width-
ReplacementFor_charsWritten);output=copy(first,end,output);
ReplacementFor_flushMaybe();return ReplacementFor_delimiterLength+static_cast<
int>(ReplacementFor_charsWritten);}inline int writeFill(ReplacementFor_uint 
ReplacementFor_count){int ReplacementFor_charsWritten=static_cast<int>(
ReplacementFor_count);if(__builtin_expect(output+ReplacementFor_count+
ReplacementFor_MAX_LENGTH<end,true)){if(ReplacementFor_count==
(0x17db+2074-0x1ff4))*output++=fill;else output=ReplacementFor_fill_n(output,
ReplacementFor_count,fill);}else for(ReplacementFor_uint chunkSize=static_cast<
ReplacementFor_uint>(ReplacementFor_buffer+ReplacementFor_BUFFER_SIZE-output);;
chunkSize=ReplacementFor_BUFFER_SIZE){if(chunkSize>ReplacementFor_count)
chunkSize=ReplacementFor_count;output=ReplacementFor_fill_n(output,chunkSize,
fill);ReplacementFor_flushMaybe();if((ReplacementFor_count-=chunkSize)==
(0x1e9+2957-0xd76))break;}return ReplacementFor_charsWritten;}public:
ReplacementFor_uint ReplacementFor_width;char fill;ReplacementFor_uint 
ReplacementFor_base;ReplacementFor_uint precision;unsigned long long 
ReplacementFor_basePower;string delimiter;ReplacementFor_OutputDevice(
ReplacementFor_OutputDevice const&)=delete;ReplacementFor_OutputDevice&operator=
(ReplacementFor_OutputDevice const&)=delete;virtual~ReplacementFor_OutputDevice(
){};inline int ReplacementFor_writeChar(char arg){ReplacementFor_separate=false;
*output++=arg;ReplacementFor_flushMaybe();return(0x1f14+887-0x228a);}inline int 
ReplacementFor_writeString(const char*arg,size_t length,bool 
ReplacementFor_checkWidth=true){ReplacementFor_separate=false;
ReplacementFor_uint ReplacementFor_count=static_cast<ReplacementFor_uint>(length
);int ReplacementFor_charsWritten=static_cast<int>(ReplacementFor_count)+(
ReplacementFor_checkWidth&&ReplacementFor_count<ReplacementFor_width?writeFill(
ReplacementFor_width-ReplacementFor_count):(0xc1f+4151-0x1c56));if(
__builtin_expect(output+ReplacementFor_count+ReplacementFor_MAX_LENGTH<end,true)
){if(ReplacementFor_count==(0x94+6657-0x1a94))*output++=*arg;else output=copy_n(
arg,ReplacementFor_count,output);}else for(ReplacementFor_uint chunkSize=
static_cast<ReplacementFor_uint>(ReplacementFor_buffer+
ReplacementFor_BUFFER_SIZE-output);;chunkSize=ReplacementFor_BUFFER_SIZE){if(
chunkSize>ReplacementFor_count)chunkSize=ReplacementFor_count;output=copy_n(arg,
chunkSize,output);ReplacementFor_flushMaybe();if((ReplacementFor_count-=
chunkSize)==(0x1475+3352-0x218d))break;arg+=chunkSize;}return 
ReplacementFor_charsWritten;}inline int ReplacementFor_writeDelimiter(){return 
ReplacementFor_writeString(delimiter.c_str(),delimiter.size(),false);}inline 
void ReplacementFor_flush(){ReplacementFor_writeToDevice(static_cast<
ReplacementFor_uint>(output-ReplacementFor_buffer));output=ReplacementFor_buffer
;}inline int write(ReplacementFor_Detail::ReplacementFor_Width 
ReplacementFor_newWidth){ReplacementFor_width=ReplacementFor_newWidth.value;
return(0x1489+2596-0x1ead);}inline int write(ReplacementFor_Detail::Fill 
ReplacementFor_newFill){fill=ReplacementFor_newFill.value;return
(0x7e0+2994-0x1392);}inline int write(ReplacementFor_Detail::ReplacementFor_Base
 ReplacementFor_newBase){ReplacementFor_base=ReplacementFor_newBase.value;
ReplacementFor_computeBasePower();return(0xc2b+2035-0x141e);}inline int write(
ReplacementFor_Detail::Precision ReplacementFor_newPrecision){precision=
ReplacementFor_newPrecision.value;ReplacementFor_computeBasePower();return
(0x20aa+1497-0x2683);}inline int write(ReplacementFor_Detail::Delimiter 
ReplacementFor_newDelimiter){delimiter=ReplacementFor_newDelimiter.value;return
(0x202f+1679-0x26be);}inline int write(){return(0x10bc+2822-0x1bc2);}inline int 
write(char arg){return ReplacementFor_writeChar(arg);}template<class 
ReplacementFor_I>inline typename enable_if<is_integral<ReplacementFor_I>::value
&&ReplacementFor_is_unsigned<ReplacementFor_I>::value,int>::type write(
ReplacementFor_I arg){return ReplacementFor_writeT(
ReplacementFor_writeUnsignedInt(arg,end));}template<class ReplacementFor_I>
inline typename enable_if<is_integral<ReplacementFor_I>::value&&
ReplacementFor_is_signed<ReplacementFor_I>::value,int>::type write(
ReplacementFor_I arg){return ReplacementFor_writeT(ReplacementFor_writeSignedInt
(arg,end));}template<class F>inline typename enable_if<is_floating_point<F>::
value,int>::type write(F arg){return ReplacementFor_writeT(
ReplacementFor_writeFloatingPoint(arg,end));}inline int write(const char*arg){
return ReplacementFor_writeString(arg,strlen(arg));}template<int 
ReplacementFor_N>inline int write(char(&arg)[ReplacementFor_N]){return 
ReplacementFor_writeString(arg,strlen(arg));}inline int write(const string&arg){
return ReplacementFor_writeString(arg.c_str(),arg.size());}template<class 
ReplacementFor_T1,class ReplacementFor_T2>inline int write(const pair<
ReplacementFor_T1,ReplacementFor_T2>&arg){int ReplacementFor_charsWritten=write(
arg.first);ReplacementFor_charsWritten+=ReplacementFor_writeDelimiter();return 
ReplacementFor_charsWritten+write(arg.second);}template<class ReplacementFor_T>
inline int write(const ReplacementFor_complex<ReplacementFor_T>&arg){return 
write(ReplacementFor_real(arg),ReplacementFor_imag(arg));}template<class 
ReplacementFor_Iterator,class...ReplacementFor_Ts>inline typename enable_if<
ReplacementFor_is_iterator<ReplacementFor_Iterator>::value,int>::type write(
ReplacementFor_Iterator first,ReplacementFor_Iterator last,ReplacementFor_Ts&&
...ReplacementFor_args){int ReplacementFor_charsWritten=(0xe5+7886-0x1fb3);for(;
first!=last;ReplacementFor_charsWritten+=++first==last?(0xf14+1432-0x14ac):
ReplacementFor_writeDelimiter())ReplacementFor_charsWritten+=write(*first);
return ReplacementFor_charsWritten+write(forward<ReplacementFor_Ts>(
ReplacementFor_args)...);}template<class ReplacementFor_Iterator,class 
ReplacementFor_I,class...ReplacementFor_Ts>inline typename enable_if<
ReplacementFor_is_iterator<ReplacementFor_Iterator>::value&&is_integral<
ReplacementFor_I>::value,int>::type write(ReplacementFor_Iterator first,
ReplacementFor_I ReplacementFor_count,ReplacementFor_Ts&&...ReplacementFor_args)
{return write(first,first+ReplacementFor_count,forward<ReplacementFor_Ts>(
ReplacementFor_args)...);}template<class ReplacementFor_T>inline auto write(
const ReplacementFor_T&arg)->decltype(arg.write(*this)){return arg.write(*this);
}template<class ReplacementFor_T0,class ReplacementFor_T1,class...
ReplacementFor_Ts>inline typename enable_if<!ReplacementFor_is_iterator<
ReplacementFor_T0>::value,int>::type write(ReplacementFor_T0&&
ReplacementFor_arg0,ReplacementFor_T1&&ReplacementFor_arg1,ReplacementFor_Ts&&
...ReplacementFor_args){int ReplacementFor_charsWritten=write(forward<
ReplacementFor_T0>(ReplacementFor_arg0));return ReplacementFor_charsWritten+
write(forward<ReplacementFor_T1>(ReplacementFor_arg1),forward<ReplacementFor_Ts>
(ReplacementFor_args)...);}};class ReplacementFor_OutputFile:public 
ReplacementFor_OutputDevice{FILE*file;bool ReplacementFor_owner;void 
ReplacementFor_writeToDevice(ReplacementFor_uint ReplacementFor_count)override{
fwrite(ReplacementFor_buffer,(0x737+5158-0x1b5c),ReplacementFor_count,file);
fflush(file);}public:ReplacementFor_OutputFile(FILE*file=stdout,bool 
ReplacementFor_takeOwnership=false):file(file),ReplacementFor_owner(
ReplacementFor_takeOwnership){}ReplacementFor_OutputFile(const char*
ReplacementFor_fileName):ReplacementFor_OutputFile(fopen(ReplacementFor_fileName
,"\x77"),true){}~ReplacementFor_OutputFile()override{ReplacementFor_flush();if(
ReplacementFor_owner)fclose(file);}};class ReplacementFor_OutputString:public 
ReplacementFor_OutputDevice{string&str;void ReplacementFor_writeToDevice(
ReplacementFor_uint ReplacementFor_count)override{str.ReplacementFor_append(
ReplacementFor_buffer,ReplacementFor_count);}public:ReplacementFor_OutputString(
string&str):ReplacementFor_OutputDevice(),str(str){}~ReplacementFor_OutputString
()override{ReplacementFor_flush();}};ReplacementFor_unique_ptr<
ReplacementFor_InputFile>input;ReplacementFor_unique_ptr<
ReplacementFor_OutputFile>output;ReplacementFor_unique_ptr<
ReplacementFor_OutputFile>logs;template<class...ReplacementFor_Ts>inline void 
read(ReplacementFor_Ts&&...ReplacementFor_args){assert(input->read(forward<
ReplacementFor_Ts>(ReplacementFor_args)...));}template<class...ReplacementFor_Ts
>inline void ReplacementFor_writeln(ReplacementFor_Ts&&...ReplacementFor_args){
logs->write(forward<ReplacementFor_Ts>(ReplacementFor_args)...,'\n');logs->
ReplacementFor_flush();}class TestCase{public:static const int ReplacementFor_N=
(0x12ed+2464-0x1c1e);int ReplacementFor_n,q;int ReplacementFor_e[
ReplacementFor_N],s[ReplacementFor_N];ReplacementFor_ll ReplacementFor_d[
ReplacementFor_N][ReplacementFor_N];int a[ReplacementFor_N],ReplacementFor_b[
ReplacementFor_N];void input(){read(ReplacementFor_n,q);ReplacementFor_REP(
ReplacementFor_i,ReplacementFor_n)read(ReplacementFor_e[ReplacementFor_i],s[
ReplacementFor_i]);ReplacementFor_REP(ReplacementFor_i,ReplacementFor_n)read(
ReplacementFor_d[ReplacementFor_i],ReplacementFor_n);ReplacementFor_REP(
ReplacementFor_i,q)read(a[ReplacementFor_i],ReplacementFor_b[ReplacementFor_i]);
}void generate(bool ReplacementFor_big,int ReplacementFor_seed){auto rnd=bind(
ReplacementFor_uniform_int_distribution<int>((0x615+721-0x8e6),
(0x2da+8835-0x2554)),ReplacementFor_default_random_engine(ReplacementFor_seed));
}void solveSlow(){output->ReplacementFor_flush();}void solve(){
ReplacementFor_REP(ReplacementFor_k,ReplacementFor_n)ReplacementFor_REP(
ReplacementFor_i,ReplacementFor_n)ReplacementFor_REP(ReplacementFor_j,
ReplacementFor_n){if(ReplacementFor_d[ReplacementFor_i][ReplacementFor_k]!=-
(0x1d7d+1085-0x21b9)&&ReplacementFor_d[ReplacementFor_k][ReplacementFor_j]!=-
(0x17dc+2858-0x2305)){ReplacementFor_ll ReplacementFor_sum=ReplacementFor_d[
ReplacementFor_i][ReplacementFor_k]+ReplacementFor_d[ReplacementFor_k][
ReplacementFor_j];if(ReplacementFor_d[ReplacementFor_i][ReplacementFor_j]==-
(0x12b7+4099-0x22b9)||ReplacementFor_sum<ReplacementFor_d[ReplacementFor_i][
ReplacementFor_j]){ReplacementFor_d[ReplacementFor_i][ReplacementFor_j]=
ReplacementFor_sum;}}}ReplacementFor_REP(ReplacementFor_i,q){vector<double>
ReplacementFor_dist(ReplacementFor_n,1e100);int ReplacementFor_x=a[
ReplacementFor_i]-(0x2b6+2642-0xd07);ReplacementFor_dist[ReplacementFor_x]=0.0;
ReplacementFor_min_queue<pair<double,int>>queue;queue.ReplacementFor_emplace(
ReplacementFor_dist[ReplacementFor_x],ReplacementFor_x);while(!queue.empty()){
auto pair=queue.top();queue.pop();int ReplacementFor_v=pair.second;if(
ReplacementFor_dist[ReplacementFor_v]<pair.first)continue;ReplacementFor_REP(
ReplacementFor_u,ReplacementFor_n)if(ReplacementFor_d[ReplacementFor_v][
ReplacementFor_u]!=-(0x1cf+3240-0xe76)&&ReplacementFor_d[ReplacementFor_v][
ReplacementFor_u]<=ReplacementFor_e[ReplacementFor_v]){double 
ReplacementFor_uDist=ReplacementFor_dist[ReplacementFor_v]+double(
ReplacementFor_d[ReplacementFor_v][ReplacementFor_u])/s[ReplacementFor_v];if(
ReplacementFor_uDist<ReplacementFor_dist[ReplacementFor_u]){ReplacementFor_dist[
ReplacementFor_u]=ReplacementFor_uDist;queue.ReplacementFor_emplace(
ReplacementFor_uDist,ReplacementFor_u);}}}write(ReplacementFor_dist[
ReplacementFor_b[ReplacementFor_i]-(0x4bc+7066-0x2055)]);}output->
ReplacementFor_flush();}string outputStr;TestCase():output(new 
ReplacementFor_OutputString(outputStr)){};private:ReplacementFor_unique_ptr<
ReplacementFor_OutputDevice>output;template<class...ReplacementFor_Ts>inline int
 write(ReplacementFor_Ts&&...ReplacementFor_args){return output->write(forward<
ReplacementFor_Ts>(ReplacementFor_args)...);}template<class...ReplacementFor_Ts>
inline int ReplacementFor_writeln(ReplacementFor_Ts&&...ReplacementFor_args){
return write(forward<ReplacementFor_Ts>(ReplacementFor_args)...,'\n');}};mutex 
inputMutex;int ReplacementFor_testIndex,ReplacementFor_testCount;vector<string>
answer;void ReplacementFor_work(){while(true){inputMutex.ReplacementFor_lock();
if(ReplacementFor_testIndex>=ReplacementFor_testCount){inputMutex.unlock();break
;}int ReplacementFor_current=ReplacementFor_testIndex++;ReplacementFor_writeln(
"\x43\x61\x73\x65\x20",ReplacementFor_current+(0x17bd+1518-0x1daa),
"\x20\x73\x74\x61\x72\x74\x65\x64");ReplacementFor_unique_ptr<TestCase>test(new 
TestCase());test->input();inputMutex.unlock();test->solve();answer[
ReplacementFor_current].swap(test->outputStr);}}void ReplacementFor_writeAnswer(
int test,const string&answer){output->write("\x43\x61\x73\x65\x20\x23",test+
(0x4c5+1002-0x8ae),"\x3a\x20",answer,"\n");output->ReplacementFor_flush();}void 
ReplacementFor_randomTest(){for(int ReplacementFor_i=(0x673+5236-0x1ae7);
ReplacementFor_i<(0x1f0c+180-0x1f5c);++ReplacementFor_i){
ReplacementFor_unique_ptr<TestCase>test(new TestCase());test->generate(false,
ReplacementFor_i);test->solve();string output;output.swap(test->outputStr);test
->solveSlow();if(test->outputStr!=output){ReplacementFor_writeln(
"\x45\x72\x72\x6f\x72\x20\x6f\x6e\x20\x74\x65\x73\x74\x20\x23",ReplacementFor_i+
(0x2160+1369-0x26b8));ReplacementFor_writeln(
"\x45\x78\x70\x65\x63\x74\x65\x64\x3a" "\n",test->outputStr);
ReplacementFor_writeln("\x52\x65\x63\x65\x69\x76\x65\x64\x3a" "\n",output);}}
ReplacementFor_writeln("\n\n" "\x54\x65\x73\x74\x20\x74\x69\x6d\x65\x3a\x20",
static_cast<double>(clock())/CLOCKS_PER_SEC);exit((0x5ad+7015-0x2114));}void 
ReplacementFor_maxTest(){for(int ReplacementFor_i=(0x1032+1265-0x1523);
ReplacementFor_i<(0x67c+1033-0xa21);++ReplacementFor_i){
ReplacementFor_unique_ptr<TestCase>test(new TestCase());test->generate(true,
ReplacementFor_i);test->solve();ReplacementFor_writeAnswer(ReplacementFor_i,test
->outputStr);}ReplacementFor_writeln(
"\n\n" "\x54\x65\x73\x74\x20\x74\x69\x6d\x65\x3a\x20",static_cast<double>(clock(
))/CLOCKS_PER_SEC);exit((0x1679+2402-0x1fdb));}int main(){input.
ReplacementFor_reset(new ReplacementFor_InputFile(
"\x43\x2d\x6c\x61\x72\x67\x65\x2e\x69\x6e"));output.ReplacementFor_reset(new 
ReplacementFor_OutputFile("\x6f\x75\x74\x70\x75\x74\x2e\x74\x78\x74"));logs.
ReplacementFor_reset(new ReplacementFor_OutputFile(stderr));logs->write(
setPrecision((0x3ff+8526-0x2549)));ReplacementFor_testIndex=(0x13bb+4797-0x2678)
;input->read(ReplacementFor_testCount);answer.resize(ReplacementFor_testCount);
#ifndef ReplacementFor_SINGLE_THREAD
vector<thread>threads;for(int ReplacementFor_i=(0x1d2+3824-0x10c2);
ReplacementFor_i<thread::hardware_concurrency();++ReplacementFor_i)threads.
emplace_back(ReplacementFor_work);for(auto&thread:threads)thread.join();for(int 
ReplacementFor_i=(0x1737+1293-0x1c44);ReplacementFor_i<ReplacementFor_testCount;
++ReplacementFor_i)ReplacementFor_writeAnswer(ReplacementFor_i,answer[
ReplacementFor_i]);
#else
for(int ReplacementFor_i=(0xab6+1302-0xfcc);ReplacementFor_i<
ReplacementFor_testCount;++ReplacementFor_i){ReplacementFor_writeln(
"\x43\x61\x73\x65\x20",ReplacementFor_i+(0xea7+5176-0x22de),
"\x20\x73\x74\x61\x72\x74\x65\x64");ReplacementFor_unique_ptr<TestCase>test(new 
TestCase());test->input();test->solve();ReplacementFor_writeAnswer(
ReplacementFor_i,test->outputStr);}
#endif
ReplacementFor_writeln("\n\n" "\x54\x6f\x74\x61\x6c\x20\x74\x69\x6d\x65\x3a\x20"
,static_cast<double>(clock())/CLOCKS_PER_SEC);return(0xb7c+4338-0x1c6e);}
